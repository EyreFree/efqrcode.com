[{"title":"上海医保异地就医","url":"/2021/11/10/Shanghai-Remote-Medical-Treatment/","content":"\n## 背景\n\n因为需要去江苏南京就医，所以在今年九月初办理了医保异地就医，过程记录一下，方便有需要的朋友。本文适用于在上海缴纳五险一金，但是需要在上海以外使用医保就医的情况。\n\n## 材料\n\n- 身份证原件；\n- 医保卡/社保卡原件；\n- 公司外派证明。\n\n身份证和社保卡都带原件这个不用多说，外派证明的话这里给大家一个例子，我就是用的这个，A4 纸打印就行，但注意一定要加盖单位公章：\n\n<center>外派工作证明</center>\n\n兹证明张三先生（身份证号码 328888888888888882）为我单位正式员工，劳动合同由 2008 年 8 月 8 日至 2018 年 8 月 8 日。   \n   \n我单位现因工作需要，外派张三先生（身份证号码 328888888888888882），至江苏省南京市从事市场拓展工作，为期 1 年。故申请办理就医关系转移手续，望接洽！   \n   \n特此证明。\n   \n<p align=\"right\">上海例子科技有限公司</br> 2021 年 11 月 11 日&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n\n## 办理\n\n- 选择上海的任意医疗保险事务中心都可以，我去的是 `普陀区医疗保险事务中心`；\n- 注意医疗保险事务中心的工作时间，避开节假日，以免白跑；\n- 疫情期间，进门出示健康码，然后跟保安大叔说你要办理医保异地就医，保安大叔会帮你在机器上取号；\n- 来办事的人一般都挺少的，我去了两次，第一次询问情况，第二次是办理，都在取号五分钟内轮到我了；\n- 叫到号时，把上面准备的三个材料给工作人员，然后你要告诉他办理异地就医，就医地点要告诉他，精确到省市区三级，且需要准备一个地址作为办公地址（因为是按工作外派办理的，实在没有的话，可以找一个目标医院附近的酒店、宾馆的地址），没什么问题的话，办好后会得到下列材料：\n\n![就医关系转移表](/images/Medical-2.jpg)\n\n![异地就医备案表](/images/Medical-3.jpg)\n\n## 注意\n\n![注意事项](/images/Medical-1.jpg)\n\n- 办理异地就医成功后，立刻生效，所以有啥检查、药要在上海准备的，弄好了之后再去医保局办理手续；\n- 异地就医关系转出后，理论上，上海本地是不能再刷这个医保卡了，只能去转出地使用；\n- 异地就医办理后，6 个月内不能转回上海，6 个月后随时可以转回；但在转出上海期间，可以多次调整省内目标地点，比如转去南京两个月，然后再转去苏州（但我没试过；\n- 在异地，医保联网的定点医院，刷上海医保卡，可以直接按报销后的价格结算；如果就医的医院，不支持医保联网，或者由于其他一些原因导致不能刷卡直接报销，则需要拿完整的资料回上海，比如出院小结、消费明细、发票等，有些医院出院的时候会给好，有些医院可能要自己去病案室打印，自己要留意，不然到时候回上海由于材料不全不给报销再往回跑会很尴尬；\n- 那么医保定点医院有哪些呢？可以下载「国家医保服务平台」App 进行搜索和查看，除此以外 App 中还可以查询包括历史消费详情等很多信息（其实很多省市区也可以在上面办理异地就医，但上海市目前还不支持通过这个 App 进行办理）：\n\n![国家医保服务平台](/images/Medical-4.jpg)\n\n## 最后\n\n- 希望以上内容对大家永远没有用；\n- 没有五险一金的朋友一定赶紧交好五险一金，注意不要断缴；\n- 请大家务必给自己和家人买好商业保险，以备不时之需。\n\n---\n\n参考资料：\n\n[上海异地就医备案流程](https://zhuanlan.zhihu.com/p/378316098)\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2021/11/10/Shanghai-Remote-Medical-Treatment   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Life"],"categories":["Life"]},{"title":"写在住院之前","url":"/2021/09/25/Before-Hospitalization/","content":"\n## 前言\n\n大家好，我是 EyreFree（EF）。\n\n既然是住院的话，我是在 2018 年 11 月确诊的，具体病情住院之后有机会的话再跟大家分享。\n\n## 前公司\n\n确诊时我就职于上家公司，负责管理移动端开发团队，工作一直兢兢业业勤勤恳恳，所以也不觉得对公司坦白会有什么问题，在初步诊断结果出来后，我把此事告知了直属上级，也就是 CTO。\n\n过完春节，也就是 2019 年 3 月，公司产品部门负责人带着运营部门负责人找到我，要求接下来整个移动端进行 007 式开发，也就是一周七天，每天 12 小时。我拒绝了，因为移动端一直是全公司加班最多的一个部门，之前 CTO 要求移动端发挥带头作用，平时就是 996 的工作状态，其他部门并不加班，而且也没有一分钱加班费，我曾经在研发部门会议上提过加班费的问题，被 CTO 一口回绝，并表示绝对不能开这个口子。\n\n随后 CTO 当晚开始对移动端的工作状况挑刺，在 22:23 质问我为啥移动端人都不在公司加班，和我说的“大家每天加班工作很辛苦”不相符合，借机发难。实际情况是前一天 App 发完新版本，大家刚忙完，而且这个语境似乎已经把员工无偿加班到晚上 10 点多认定为是员工的本分了，当时我正坐在公司工位上加班。第二天 CTO 找我谈话，对我拒绝 007 的事表示“你对我们说 No 我们也对你说 No”，以行政命令的方式强制整个移动端实行 007 工作制直到月底。我见领导铁了心要逼大家加班，只能退而求其次，申请了一个所谓的加班补贴 2000 块 RMB，在三月底给到比较辛苦的三位同事，1 个 1000 元，2 个 500 元，这是当时的加班记录 [三月突击计划结算表](https://docs.qq.com/sheet/DVmhuREhFa3lhcnNO?tab=BB08J2)（表中早退指 22:30 前下班），下图是 CTO 和我的企业微信聊天记录：\n\n![找茬](/images/IMG_12.png)\n\n在 3 月底，HR 以「公司上市需要做账」为由，要求移动端员工改签劳动合同，过程中没有涨薪，但在这份新合同中，把基本工资的 20% 变为了“绩效工资”，实际上也就是变相降薪，因为根据新合同的规定，绩效工资发多少由公司根据当月表现来定，也就是最少可以一分不给。而且新增了多条类似「员工身体健康状况发生变化」和「员工无法胜任工作」后公司如何做岗位调整和解除劳动合同的条款。对于绩效工资，我很直白地问了负责改签合同的 HR 如果公司不给钱怎么办，她只是答复了一堆「公司只是为了做避税和方便管理，员工和公司之间要相互信任」之类的话术。新合同中还对加班制度作了规定，提及了加班费和加班申请等，但实际上这些文本只是为了符合相关法律规定装样子的摆设罢了，因为不管是在这之前还是之后，不管是工作日的超出 8 小时后的加班还是非工作日的加班，不管是 996 还是 007，公司没有给任何普通员工发过哪怕一分钱的加班费。\n\n4 月 10 日，CTO 表示 007 继续，从 11 号开始到月底，这是 4 月份的加班记录 [四月突击计划结算表](https://docs.qq.com/sheet/DVkdLWUpoT0FPU0dO?tab=BB08J2)，点开链接的朋友会发现里面只记了 4 月 11 日一天，没错因为我被降职了。4 月 12 号，CTO 找到我表示公司组织架构调整，移动端和前端组合并成立大前端，前端负责人为新的 Leader，并表示这是 3 月决定的事，没有任何其他理由。新的大前端部门成立一周后，公司把前端开发工程师全部裁掉了，所以实际上大前端也就是移动端换个名字而已，很新颖的操作方式。然后 007 照旧到月底，但加班不用记录了，因为这次没人去给团队申请 2000 块了。\n\n期间内推我的同事告诉我，他找 CEO 沟通了我的事情，CEO 的说法是”虽然 EF 自己能为公司加班，但他不能带动团队一起加班”，我听完就满脸问号，所以移动端之前无偿 996 和 007 给公司加班算啥，不存在？从公司的这一番操作中，我感觉自己被刻意针对了，但也没有十分确定的证据。因为 6 月有年中绩效评估（调薪），在被降职后我找到 CTO 表示希望公司不要故意针对我把我排除在调薪范围之外，CTO 当场许诺会给我调薪，甚至明确告诉我涨幅是 15%。得到超出预期的答复后，我觉得可能我之前想多了，自己以小人之心度君子之腹。\n\n随后公司入职了一个技术 VP，他对我们说原来的 CTO 已经把岗位让给了他，现在他是新的 CTO 了，负责管理研发团队，并表示接下来要对研发团队做改革，精简裁撤，好好表现努力工作的人能够留下来得到加薪，大概意思就是胡萝卜加大棒。并在找我谈话时表示 CEO 对他说“移动端所有人都可以开掉”，因为他并不了解我的病情所以觉得用 CEO 的话可以震慑我，但我却从中获得了一个信息：CEO 似乎在暗示他把我开掉？\n\n之后发生的事情，当时在公司工作的朋友们应该都知道。七月初，移动端之前我招进来的 iOS & Android 工程师此时有毕海湉、夏启波、张文超、王世超、刘庆、王顺扬、王杰，共 7 人，除了张文超以外全都被辞退。辞退理由是绩效不达标、技术菜之类莫须有的罪名，辞退补偿是三周的薪水（因为 Android 当时缺人，后面他们招到新的 Android 工程师后把张文超也裁掉了，大概 9 月初）。毕海湉是我招进公司的 Android 开发小姐姐，技术和工作能力都很强，进入公司后统筹 Android 项目开发，辞退时间发生时她正在休婚假，休完假回到公司当天就被辞退。也就是说，在整个移动端团队 3、4 月份 007 高强度加班两个月，平时也保持 996 的开发节奏，并且从未出现过重大生产事故的情况下，几乎整个团队被开掉了，并且赔偿还是完全不合法的三周薪水，被开除之前大家还在天真地期待着年中绩效考评升职加薪。下图是当时和张文超的微信聊天记录，还记得之前改签的那份新合同么？1800 元是用 20% 绩效工资手段扣掉的：\n\n![张文超被辞退](/images/IMG_10.png)\n\n关于张文超菜不菜这个问题，可能我作为当事人下的结论会让人觉得可信度不高，这是他的 GitHub：[https://github.com/Zackratos](https://github.com/Zackratos)，做 Android 开发的朋友可以自己评估。据我了解到的情况是张文超之后接了 Soul 的 Offer，毕海湉去了哈喽单车，其他同事也都很快找到了合适的工作。\n\n另外关于离职补偿为啥是三周这个问题我很长一段时间一直没想明白，直到有一次遇到老领导丹哥，他第一反应就是问了一句“你们是不是劳动合同走的避税？”，算了一下按避税的基本工资计算 N+1 差不多就是真实工资三周的数字了，这大概就是 CTO 有底气叫嚣“你可以去仲裁”的原因吧。\n\n接下来，年中绩效评估结果出来了，看到这里的朋友到这应该知道，不管是 CTO 还是 VP 都许诺了此时会给到涨薪，接下来到了兑现的时候了。七月底，VP 找到我沟通年中绩效评估。通知我我的年中绩效结果是 3 分（满分 5 分），并表示有其他领导想给我打 2 分让我走人，是他力挽狂澜保住了我，并让我以后好好表现，之前许诺的涨薪只字未提，并且对我进行了一番 PUA，说我工作做得不好这也不行那也不行之类的。几天后，CTO 也找我谈话，表示之前口头答应给到我的涨薪不给了，告诉我直接原因是他在 VP 面前帮我提了调薪但被 VP 否决了，并表示虽然之前口头许诺了我涨薪，但公司就是靠层层压榨攫取利益的，既然我现在不是 Leader 了不愿意和公司一起压榨手下的员工，那自然也享受不到压榨员工带来的好处。\n\n当天加了公司离职员工群，把从三月开始的这些事（也就是上文这些内容）简单描述了一下，发到了群里，但可能没有这么详细，并跟圈子里的一些朋友沟通我的遭遇。第二天，HR 部门负责人找我谈话，大致就是让我不要继续搞事情。随后 CTO 也找我谈话，我对他转述了 VP 说的话，他表示我说的内容和他了解到的事实有出入，随后我表示“VP 在会上说留下来的同事有涨薪，这个会你也在场的吧？”，CTO 沉默了，之后表示会帮我把答应的涨薪争取回来。最后给到的方案是公司每月给我所谓的「帮扶金」，由他们这些公司高管一起出钱，数额大概就是之前答应我的 15% 涨薪的额度，但这笔钱的性质此时已经完全变了。期间 CEO 也找到我，给我支付宝转账 1 万块，表示对我的帮助。\n\n这件事之后，我便开始考虑之后如何维持生计的问题，因为领导宁愿给所谓的「帮扶金」也不愿给我涨哪怕一块钱已经摆明了姿态，公司不会给我任何涨薪。之后的几个月里，我不断滴找一些朋友、同事、老乡越聊创业的事情希望能自力更生，因为不想再换一家公司工作，倒不是真的因为身体原因影响工作能力，只是怕坑人，但始终没有比较好的机会。\n\n在这期间，各种针对我的劝退行为一直没有停：\n- 比如刚调前端 Leader 来管理移动端时，因为新领导压根不懂 App 开发，所以移动端很多同事不适应，我在公司找他们沟通让他们好好配合新领导工作，结果 VP 找到我说新 Leader 投诉我私下和移动端同事串联教唆他们造反，让我停止搞事情，再犯就要处分我；\n- 年中绩效考评时给到移动端组的绩效是全公司倒数第二，理由是稳定性指标降低了，没错原因是需求多加班赶进度频繁发版本出现了一些需求延误和几个小 Bug，也就是说移动端加班不仅不给加班费，而且还亏钱；\n- 八月初的公司月度会议，公司政府关系部门的负责人在台上表示自己又联合某地公安抓获了薅公司运营活动羊毛的团伙帮公司挽回了损失，并公开点名我说“EF 都是你的工作没做好”，我寻思被薅的运营活动是前端组做的微信小程序的，出问题的接口是后端写的，跟我一个 iOS 开发有啥关系？但话语权在他们手上，而且确实十分有效，因为公司大部分人都是不懂技术的，真就认为这事怪我是我给公司造成了损失；\n- 公司领导不断在各种场合宣称公司业务做不起来怪移动端开发，因为 App 是开发人员做的，数据起不来就是开发的能力问题。\n\n10 月底，CTO 找我谈话，表示“不希望看到我继续在这家公司浪费时间”，我花了一周时间面试，拿了几家公司的 Offer，并在 11 月上旬办理了离职手续。即使在这时，我仍然抱着“他们顶多就是觉得我身体不行了不能继续正常工作所以不停劝退我而已”的想法，接下来发生的事情让我知道我确实想法太单纯了。在我离职后没多久的 12 月初，公司开始进行大规模 N+1 裁员，难怪之前不停劝退我，原来是为了省掉 N+1 的钱，恭喜他们，省下了对我来说算得上是救命钱的 10 万块，可能是要把这笔钱投入到他们的公益慈善事业中去吧，是我格局小了。\n\n因为当时身在局中，所以不太看得明白，之后跟朋友聊起这些事，朋友很直白地告诉我，从结果往前反推的话，整件事情的脉络就十分清晰了：因为跟朋友们聊的时候他们知道我的具体病情，CTO 所谓的让移动端带头 996 的时候，就已经是在针对我了，虽然在这之前的刚过完年给我涨过一次薪，但类比之后「大前端」，这么操作只是为了避免太过直接显得刻意针对而已。公司其他部门都不加班，单单让移动端加班，本就很反常。在我得了患病的情况下，坚持带病无偿 996 加班公司不仅没有任何认可，3、4 月份继续加码逼迫无偿 007，已经是赤裸裸逼我走，因为他们觉得我肯定扛不住，没想到我竟然还坚持下来了，所以 4 月份他们就直接动手把我 Leader 撤了，然后用涨薪的许诺先稳住我，再把我招进来的员工一个个都裁撤掉，接着食言不给我之前许诺的涨薪，此时我只剩孤身一人对他们构不成任何威胁。对了，前面 CEO 给的 1 万块是拿来稳住我的不是奔着帮我，因为之后公司要用补偿三周的方式裁掉其他部门同事时，有一个 UI 小姐姐（阿菲）受不了打算号召大家集体仲裁，CEO 也熟练地掏出了 1 万块，到这个时候我才明白，都是套路。\n\n在确诊后他们不停质疑我的工作能力，而我为了证明我的病情不影响我的工作能力只能不断加班（看三月份的加班表就知道了），所以有意思的是，为了不被公司找借口拿我的病情说事，我还得付出比以前正常时更多的工作量和工作时间。但并没有什么用，因为他们是奔着劝退我的目标去的，不加班就说工作投入度不高，加班了就挑刺没达到运营数据指标，最后把我 Leader 都撤了之后 CTO 仍然三天两头找我谈话挑我刺，即使此时我的直属上级已经不是他了。我没有得到过任何主动的帮助，甚至相反，我面对的是主动的恶意。只能说我从一开始就没想到这样一群履历光鲜的人，“来自硅谷、小红书、阿里、微软、百度等的 一群创业者”，会这样对我一个患病的人吧。\n\n## 现公司\n\n2019 年的 11 月上旬入职了潮玩族，也就是回响科技。其实刚换了工作每月收入反而少了，因为我没有把上家公司的「补助」说成是自己的薪水，但终于到了一个可以正常工作的环境。\n\n其实中间过程也有一些曲折，最终去了回响。既不是因为回响的薪资更高也不是因为其他公司背调没有通过或者其它一些原因，而是因为在知道我身体不是很好后他们仍然选择接纳我，虽然我没有向他们透露具体的病情，只是表示等治好了再告诉他们具体情况。\n\n进入公司后正常工作，每月去医院随访检查。就这样一直到 2020 年的 8 月，此时我已经药物维持治疗两年了，我做了相应的检测，结果没有转阴。经过确诊后不断的自我学习，我明白这个检测结果意味着服药可能无法使我获得治愈，所以我在 9 月底请了一天病假，去找治疗这个分型比较权威的教授门诊，希望能给出有机会获得治愈的治疗方案，他看完我的病历与各项检查报告后表示如果刚开始就去他那里治疗结果可能会比现在好，既然现在已经服药维持了这么长时间并且看起来情况还算稳定，之后我可以在合适的时候去住院进行根治性治疗。\n\n此后，我一边做入院治疗的各项准备，一边继续工作攒钱。2021 年 3 月发完年终奖后，我终于凑够了住院治疗需要的 30 多万，然后向公司告知了具体病情并表示接下来可能会需要住院治疗一段时间。CEO 沈振宇在得知我的具体病情后，表示如果在疾病治疗上有经济困难可以直接找他开口，并且先不用考虑怎么还的问题。因为他有校友得过类似的疾病（和我差一个分型），所以他可能对我的疾病也有一定的了解。说实话我挺感动的，确诊到现在第一次有人在得知我的病情后愿意给我提供实质性的帮助。尤其是在经过前公司的一系列事情之后。当然我事后也对 HR Nicole 说，不能因为我目前在这家公司工作，CEO 就倒了霉似的要给我这笔钱帮助我，如果真的有一天我撑不住了，肯定会是公开病情寻求所有人的帮助。下图是过去两年医保系统记录的医疗费用汇总：\n\n![医疗费用汇总](/images/IMG_13.png)\n\n接下来的时间里因为等待新药上市、疫情等原因，中间延期了两次，最后于 9 月初，我请了病假准备住院做根治性治疗。在写这篇文章时，我正在忙着住院前的核酸检测、医院的原始检测材料、异地医保等的办理。\n\n如果我不告诉别人我的病情，也许没有人能看得出我是一个病人。当然了，除了大家都对我戴的“痛苦面具”感到好奇以外。\n\n![3M防毒面具](/images/IMG_3.png)\n\n## 感谢\n\n感谢倪雪萍、王顺扬、忧伤珲舞、周国建、Yuu（郑宇琦）、ToothLess、SunnyYoung、Andself、肖玮荣、moscato、Evan、吕晨、周锦林、黄辰学长、何翌、tung、王浙剑、于德志、世杰、欧阳日鹏、胡尼玛、李蕊、DarrenW、周凌宇、芮寅康、Cathy、Laker、倪瑶、李楠、李奎、Nicole（王茜）、沈强、MM（郑宜东）、瓜神、XY、李一丹、刘金龙、吴家欢、POJO 博士、粉总、沈振宇、AidenRao、黄河、王杰、毕海湉、小胖、刘庆、肖子浩、丹哥、王世超、钱弘扬、L、小文姐、梧桐、雪碧、洪帮主、笛子姐等所有在过程中对我提供过关心、鼓励和帮助的朋友，祝大家诸事顺利。\n\n同时也希望所有朋友身体健康，不要像我一样逛医院如喝水吃饭，当然了，为了以防万一还是请务必给自己和家人买好商业保险。\n\n## 最后\n\n有人就要问了，住院治个病而已，弄得像道别似的这么隆重，最后屁事没有五年、十年以后还在蹦跶就太打脸了。\n\n我想说：还有这种好事？\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2021/09/25/Before-Hospitalization   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Nothing"],"categories":["iOS"]},{"title":"EyreFree 的茶叶店","url":"/2021/02/22/Tea/","content":"\nEyreFree 老家自营茶场，新茶上市啦，碧螺春（新茶）666 元/斤，欢迎选购！\n\n另现货供应各种茶叶：\n\n| 序号 | 品名 | 单价（元 / 斤） |\n|:-----|:-----|:-----|\n| 1 | 宜兴红茶（普通） | 240 |\n| 2 | 宜兴红茶（中档） | 350 |\n| 3 | 宜兴红茶（高档） | 460 |\n| 4 | 宜兴红茶（特等） | 580 |\n| 5 | 碧螺春（普通） | 260 |\n| 6 | 碧螺春（中档） | 380 |\n| 7 | 碧螺春（高档） | 500 |\n| 8 | 碧螺春（特等） | 600 |\n| 9 | 碧螺春（新茶） | 666 |\n| 10 | 宜兴白茶（高档） | 888 |\n| 11 | 宜兴白茶（特等） | 1200 |\n| 12 | 金骏眉（高档） | 888 |\n| 13 | 金骏眉（特等） | 1200 |\n| 14 | 黄金叶（高档） | 1200 |\n| 15 | 黄金叶（特等） | 2333 |\n\n有冷库保鲜，一年四季供应鲜茶，并有老红茶 / 机制红茶专供养壶。另供应各种机制 / 手工绿茶，价格优惠，送礼 / 自用佳品（礼盒可选配，单独付费）。\n\n购买总价满 300 RMB 包邮（偏远地区另议），支持微信 / 支付宝 / 银行卡转账。\n\nQQ：1795179491\n微信：EyreFree\n邮箱：eyrefree@eyrefree.org\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2021/02/22/Tea   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Other"],"categories":["Other"]},{"title":"Flutter 与 Swift 混编项目启用 Bitcode","url":"/2020/11/17/Flutter-Bitcode/","content":"\n因为手头在做的项目是 Flutter 与 Swift 混编的，然后之前是已经启用 Bitcode 的，刚接入 Flutter 的时候，我把 Bitcode 的各种设置都启用了，比如：\n\n1. 将各个 target 的 `Enable Bitcode` 选项设为 `Yes`；\n2. 在 `Podfile` 尾部添加如下代码将 pod 的 `Enable Bitcode` 打开：\n\n```ruby\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings['ENABLE_BITCODE'] = 'YES'\n    end\n  end\nend\n```\n\n但 Archive 时会报错，类似如下的错误输出：\n\n```bash\nbitcode bundle could not be generated because '/.../.ios/Flutter/engine/Flutter.framework/Flutter' was built without full bitcode. All frameworks and dylibs for bitcode must be generated from Xcode Archive or Install build file '/.../.ios/Flutter/engine/Flutter.framework/Flutter' for architecture armv7\n```\n\n找了一圈得到的回复基本都是 `修改 pod 库的 ENABLE_BITCODE = NO（因为 Flutter 现在不支持 bitcode）`，所以暂时关闭了。\n\n但最近包体积膨胀得厉害，所以又回头来找找解决方案，毕竟 Flutter 官方是号称支持 Bitcode 的，而且还一本正经地搞了一个 [Creating an iOS Bitcode enabled app](https://github.com/flutter/flutter/wiki/Creating-an-iOS-Bitcode-enabled-app) 文档。\n\n果然最后在 issue 里翻到了 [解决方案](https://github.com/flutter/flutter/issues/48092#issuecomment-577345215)：\n\n在 Archive 之前终端切换到 flutter 模块下执行一次 `flutter build ios --release` 然后再 Archive 就可以了，已成功提交审核并上架 App Store，Adhoc 包也没问题。\n\n![想不到吧](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1605613608337&di=c1eb216cb8a9c37b0ed37b622cb7249c&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201703%2F07%2F20170307134555_jtF2H.thumb.700_0.jpeg)\n\n顺便贴一下我的 flutter doctor 输出：\n\n```bash\n[✓] Flutter (Channel unknown, 1.22.3, on Mac OS X 10.15.5 19F96, locale\n    zh-Hans-CN)\n    • Flutter version 1.22.3 at /Users/eyrefree/Documents/Tools/flutter\n    • Framework revision 8874f21e79 (3 weeks ago), 2020-10-29 14:14:35 -0700\n    • Engine revision a1440ca392\n    • Dart version 2.10.3\n    • Pub download mirror https://pub.flutter-io.cn\n    • Flutter download mirror https://storage.flutter-io.cn\n\n[✓] Android toolchain - develop for Android devices (Android SDK version 30.0.0)\n    • Android SDK at /Users/eyrefree/Library/Android/sdk\n    • Platform android-30, build-tools 30.0.0\n    • ANDROID_HOME = /Users/eyrefree/Library/Android/sdk\n    • Java binary at: /Applications/Android\n      Studio.app/Contents/jre/jdk/Contents/Home/bin/java\n    • Java version OpenJDK Runtime Environment (build\n      1.8.0_242-release-1644-b3-6222593)\n    • All Android licenses accepted.\n\n[✓] Xcode - develop for iOS and macOS (Xcode 12.2)\n    • Xcode at /Applications/Xcode.app/Contents/Developer\n    • Xcode 12.2, Build version 12B45b\n    • CocoaPods version 1.10.0\n\n[✓] Android Studio (version 4.0)\n    • Android Studio at /Applications/Android Studio.app/Contents\n    • Flutter plugin version 46.0.2\n    • Dart plugin version 193.7361\n    • Java version OpenJDK Runtime Environment (build\n      1.8.0_242-release-1644-b3-6222593)\n\n[✓] VS Code (version 1.51.0)\n    • VS Code at /Applications/Visual Studio Code.app/Contents\n    • Flutter extension version 3.16.0\n```\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2020/11/17/Flutter-Bitcode   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Swift"],"categories":["iOS"]},{"title":"如何实现通过 NFC 标签唤起 App Clips","url":"/2020/09/27/NFC-AppClips/","content":"\nApple 在 WWDC2020 推出 App Clips 之后引起了不少相关的讨论，很多同学对这种 iOS 平台的 `小程序` 感到很好奇，下面我们就来看看如何通过 NFC 标签来唤起 App Clips 吧。\n\n## NFC 简介\n\nNFC 是 Near Field Communication 的首字母缩写，即近场通信，也被称为近距离无线通信，是一种短距离的高频无线通信技术，通过在单一芯片上集成感应式读卡器、感应式卡片和点对点通信的功能，利用移动设备实现移动支付、电子票务、门禁、移动身份识别、防伪等功能。\n\n![一种 NFC 标签](/images/NFC-AppClips-1.jpg)\n\n### 1. 起源\n\n大约在 2003 年，索尼公司和飞利浦半导体（现为恩智浦 NXP 半导体）进行合作，计划基于 RFID 研发一种更加安全快捷并且能与之兼容的无线通讯技术，不久后双方联合对外发布了一种兼容 IS014443 非接触式卡协议的无线通讯技术，取名为 NFC，具体通信规范称作 [NFCIP-1](https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-340.pdf) 规范。随后，索尼、飞利浦与诺基亚一起，创建 NFC 论坛，开始推广 NFC 的应用。\n\n### 2. 原理\n\nNFC 是一种短距高频的无线电技术，NFCIP-1 标准规定 NFC 的通信距离为 10 厘米以内，运行频率 13.56 MHz，传输速度有106 Kbit/s、212 Kbit/s 或者 424 Kbit/s 三种。NFCIP-1 标准详细规定 NFC 设备的传输速度、编解码方法、调制方案以及射频接口的帧格式，此标准中还定义了 NFC 的传输协议，其中包括启动协议和数据交换方法等。\n\nNFC 工作模式分为被动模式和主动模式：\n\n- 被动模式\n\nNFC 发起设备（也称为主设备）利用供电设备的能量来提供射频场，并将数据发送到 NFC 目标设备（也称作从设备）。根据电磁感应原理，从设备利用主设备产生的射频场转换为电能，为从设备的电路供电，接收主设备发送的数据，并且以相同的速度将从设备数据传回主设备。\n\n- 主动模式\n\n发起设备和目标设备在向对方发送数据时，都必须主动产生射频场，所以称为主动模式，它们都需要供电设备来提供产生射频场的能量。这种通信模式可以获得非常快速的连接速率。\n\n### 3. 应用\n\n#### 支付应用\n\nNFC 支付主要是指带有 NFC 功能的手机虚拟成银行卡、一卡通等的应用。\n\n![地铁、公交](/images/NFC-AppClips-2.jpg)\n\n#### 安防应用\n\nNFC 安防的应用主要是将手机虚拟成门禁卡、电子门票等。 NFC 虚拟门禁卡就是将现有的门禁卡数据写入手机的 NFC，使用手机就可以实现门禁功能，门禁的配置、监控和修改等都会变得十分方便，而且可以实现远程修改和配置，例如在需要时临时分发凭证卡等。 \n\n![门禁卡](/images/NFC-AppClips-3.jpg)\n\n#### 标签应用\n\nNFC 标签应用就是把一些信息写入一个 NFC 标签内， 用户只需用 NFC 手机或准备好的设备在 NFC 标签上挥一挥就可以立即获得相关的信息。例如商家可以把含有海报、促销信息、广告的 NFC 标签放在店门口，用户可以根据自己的需求用NFC手机获取相关的信息。\n\n![amiibo](/images/NFC-AppClips-4.jpg)\n\n## App Clips 创建\n\n唔，这里以 [EFQRCode](https://github.com/EFPrefix/EFQRCode/tree/appclips) 的 iOS Demo 为例进行演示。\n\n### 1. 开发环境和设备\n\n首先请安装好 Xcode 12，然后请准备一台已经升级到 iOS 14 的[支持 NFC 的 iOS 设备](https://www.bluebite.com/nfc/iphone-nfc-compatibility)用于测试，我这里是用的是 iPhone X。\n\n|   | Has NFC | Card Emulation | NFC Payments | Reads NFC | Writes NFC |\n|--:|:-------:|:--------------:|:------------:|:---------:|:----------:|\n| iPhone 11, 11 Pro / Max, SE (2nd Gen) | ✓ | ✓ | ✓ | ✓ | ✓ |\n| iPhone XS, XS Max, XR | ✓ | ✓ | ✓ | ✓ | ✓ |\n| iPhone X, 8, 8+, 7, 7+ | ✓ | ✓ | ✓ | ✓* | ✓ |\n| iPhone 6, 6+, 6S, 6S+, SE (1st Gen) | ✓ | ✓ | ✓ | ✗ | ✗ |\n| iPhone 5S, 5C, 5, 4S, 4, 3GS, 3G | ✗ | ✗ | ✗ | ✗ | ✗ |\n\n### 2. 创建 App Clip Target\n\n切换到 Project 的 Targets 列表，点击左下角 `+` 号找到 `App Clip` 项目，添加 Target：\n\n![创建 Target](/images/NFC-AppClips-5.png)\n\n### 3. apple-app-site-association\n\n扫描 NFC 标签打开对应 App Clips / App 实际上是读取了 NFC 标签数据区的 URL 然后打开该 URL 绑定的 App Clips / App，听起来是不是和 Universal Link 很像？所以类似地，需要在想关联的域名下添加 `apple-app-site-association` 文件，并在其中写入 `appclips` 对应的内容，`apps` 值格式为 `DevelopmentTeamID.BundleID`（DevelopmentTeamID 和 BundleID 请替换为你自己的），下面是 [EFQRCode 的](http://efqrcode.com/apple-app-site-association)：\n\n```\n{\n    \"appclips\": {\n        \"apps\": [\"P3X2725LYY.AppStore.EFQRCode.Clip\"]\n    }\n    \"applinks\": {\n        \"apps\": [],\n        \"details\": [\n            {\n                \"appID\": \"P3X2725LYY.AppStore.EFQRCode\",\n                \"paths\": [ \"*\" ]\n            }\n        ]\n    }\n}\n```\n\n同时我们切换到刚创建的 App Clip 的 `Signing & Capabilities` 选项卡下，点击左上角的 `+ Capability` 添加 `Associated Domains`，EFQRCode 的如下：\n\n![Associated Domains](/images/NFC-AppClips-6.png)\n\n### 4. Hello World\n\n此时我们在 Xcode 左上角选择 Clip 的 Scheme 进行编译，可以启动一个带有 Hello World 字样的空的 App Clip。\n\n### 5. 添加代码获取唤起 Clip 的 URL\n\n打开我们创建的 App Clip，找到入口文件 `appclipApp.swift` 然后添加如下代码，这里使用的是 SwiftUI 方式进行开发：\n\n```swift\nimport SwiftUI\n\n@main\nstruct appclipApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .onContinueUserActivity(NSUserActivityTypeBrowsingWeb, perform: { userActivity in\n                    guard let incomingURL = userActivity.webpageURL,\n                          let components = NSURLComponents(url: incomingURL, resolvingAgainstBaseURL: true),\n                          let queryItems = components.queryItems else {\n                        return\n                    }\n                    print(incomingURL)\n                    print(components)\n                    print(queryItems)\n                })\n        }\n    }\n}\n```\n## App Clip 的 NFC 唤起\n\n### 1. 制备 NFC 标签\n\n在唤起 Clip 之前，我们需要先制备能够唤起 Clip 的 NFC 标签，同学们可以在淘宝搜索 `NFC 标签贴` 买到空白的 NFC 标签，我这边准备的是 `ISO 14443-3A` 类型的 NFC 便利贴，小小的，可以贴在玩具底座上，如下图所示：\n\n![NFC 便利贴](/images/NFC-AppClips-7.jpg)\n\n刚买到的 NFC 标签是空白的，并不包含数据，所以用 iPhone 贴近 NFC 标签并不会有任何响应。接下来我们打开 App Store 搜索 NFC Tools 随便找一个 NFC 读写器来完成我们对 NFC 标签的读写，这边我是用的是 [NFC Tools](https://apps.apple.com/cn/app/nfc-tools/id1252962749)。\n\n打开 NFC Tools 选择 `读` 选项，当 NFC 扫描弹框出现后，将手机的背部摄像头位置靠近我们准备好的 NFC 标签，即可读出标签内的数据（如果没有识别到的话，可以尝试调整位置或扫描姿势，反正我用的 iPhone X 的 NFC 感应器是在摄像头旁边一点的样子），可以看到目前 NFC 标签内是没有写入任何数据的，只有一些基本信息，并且是可写状态，如下图所示：\n\n![读取空白 NFC 标签内的数据](/images/NFC-AppClips-8.png)\n\n回到 NFC Tools 首页，选择 `写` -> `添加记录` -> `URL / URI`，将我们上面配好的 Associated Domains 地址填入，然后回到写数据页面，点击 `写 / 17 字节` 选项，再将手机贴近 NFC 标签，等待写入成功。这时，我们再使用 `读` 功能读取 NFC 标签内的数据，可以看到我们写入的 URL 记录：\n\n![写入数据](/images/NFC-AppClips-9.png)\n\n### 2. 唤起 Clip\n\n此时我们退出 NFC Tools 回到桌面，将 iPhone 贴近制备好的 NFC 标签，可以看到 iPhone 已经能识别到 NFC 标签内我们写入的 URL，但它并没有唤起我们的 App Clip，而是询问是否用 Safari 打开，这好像和我们的设想有些出入。\n\n![询问是否用 Safari 打开](/images/NFC-AppClips-10.jpg)\n\n唔，这是因为我们的 Clip 并没有上架，所以 iOS 现在并不知道这个 URL 和我们 App Clip 的绑定关系。这个时候我们可以打开 `设置` -> `开发者`，可以看到有 `APP CLIP TESTING` 一项，点击 `Local Experiences` -> `Register Local Experiences` 添加我们的测试数据即可，添加完成后再用 iPhone 靠近 NFC 标签即可成功唤起 Clip：\n\n![唤起 Clip](/images/NFC-AppClips-11.jpg)\n\n唤起成功啦，接下来就可以动手给 Clip 添加内容了呢。\n\n## 后记\n\n本文代码可从 https://github.com/EFPrefix/EFQRCode/tree/appclips 获取，有一些上文没有提到但需要注意的点：\n\n- 一个 App 能且只能拥有一个 App Clip；\n- App Clip 的包大小上限为 10M，如何合理封装、复用现有代码，需要花一些时间思考；\n- 如果用户已经安装了 App，那么会直接唤起 App 而不是 Clip。\n\n那么问题来了，实际生活中有哪些业务需求可以用到这个酷炫的能力呢？小伙伴们需要自己思考啦...\n\n本文编写过程中参考了以下文章，在此对原作者们表示感谢：\n\n- [一些关于 App Clips 的笔记](https://onevcat.com/2020/06/first-look-app-clips/)\n- [App Clips简介以及demo演示](http://www.cocoachina.com/articles/899697)\n- [iPhone NFC Compatibility](https://www.bluebite.com/nfc/iphone-nfc-compatibility)\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2020/09/27/NFC-AppClips   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Swift"],"categories":["iOS"]},{"title":"CocoaPods installed but not initialized. Skipping pod install","url":"/2019/10/17/CocoaPods-Flutter-CDN/","content":"\n流水账警告，⚠️\n\n---\n\nCocoaPods [1.8.0](http://blog.cocoapods.org/CocoaPods-1.8.0-beta/) 支持了 CDN，速度比以前快了很多，这么棒当然是赶紧用起来了，于是推动组内升到了 1.8.3 并移除了无用的 repo，然后 Jenkins 打包就炸了，发现报错：\n\n```\n/Users/XXX/Desktop/jenkinsWorkspace/workspace/x_iOS/XXX/XXX-Bridging-Header.h:60:9: 'FlutterPluginRegistrant/GeneratedPluginRegistrant.h' file not found\n```\n\n唔，看起来是依赖的 Flutter 模块炸了，去 Flutter 的打包日志看看，找到如下报错：\n\n```\nBuild...\nWarning: Building for device with codesigning disabled. You will have to manually codesign before deploying to device.\nBuilding com.x w s.XXX for device (ios-release)...\nWarning: CocoaPods installed but not initialized. Skipping pod install.\n  CocoaPods is used to retrieve the iOS platform side's plugin code that responds to your plugin usage on the Dart side.\n  Without resolving iOS dependencies with CocoaPods, plugins will not work on iOS.\n  For more info, see https://flutter.io/platform-plugins\nTo initialize CocoaPods, run:\n  pod setup\nonce to finalize CocoaPods' installation.\nRunning Xcode build...                                          \nXcode build done.                                           57.4s\nFailed to build iOS app\nError output from Xcode build:\n↳\n    ** BUILD FAILED **\n```\n\n噫，`pod install` 被跳过了？切到打包机执行了 `flutter doctor` 命令，查看一下是不是 flutter 环境坏掉了：\n\n```\nDoctor summary (to see all details, run flutter doctor -v):\n[✓] Flutter (Channel beta, v1.3.8, on Mac OS X 10.14.6 18G95, locale zh-Hans-CN)\n[✓] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n[!] iOS toolchain - develop for iOS devices (Xcode 11.1)\n    ✗ CocoaPods installed but not initialized.\n        CocoaPods is used to retrieve the iOS platform side's plugin code that responds to your plugin usage on the Dart side.\n        Without resolving iOS dependencies with CocoaPods, plugins will not work on iOS.\n        For more info, see https://flutter.io/platform-plugins\n      To initialize CocoaPods, run:\n        pod setup\n      once to finalize CocoaPods' installation.\n[✓] Android Studio (version 3.2)\n[!] Connected device\n    ! No devices available\n```\n\n唔，出现了一样的报错，看起来是升级 CocoaPods 导致的异常。按日志的提示我们执行了 `pod setup`，操作成功！ `flutter doctor` 报错依旧。咦，怎么肥事？经过 [一番搜索](https://github.com/flutter/flutter/issues/41291) 发现，CocoaPods 1.8.x 以下在 setup 时初始化的 repo 是 `master`，而 1.8.x 已经不再是这个了：\n\n![](/images/CocoaPods-Flutter-CDN-1.png)\n\n但不知道是 flutter 还是 CocoaPods 的问题（可能是因为我们用的 flutter 版本低了，是 1.3.8），打包过程会通过检测旧版本的主 repo 是否存在来判断 CocoaPods 是否已经初始化，所以我们需要先切换到 1.7.5，然后执行 `pod setup`，再切回 1.8.3 即可，`flutter doctor` 显示正常，打包也恢复正常了。\n\n```\nsudo gem uninstall cocoapods\nsudo gem install cocoapods -v 1.7.5\npod setup\n```\n\n然后再安装最新版 CocoaPods 就可以了：\n\n```\nsudo gem install cocoapods\n```\n\n提示：记住这里千万不要删除多余的 repo，不然你就会像我一样需要白忙活 2 个小时，首尾呼应，完结撒花。\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2019/10/17/CocoaPods-Flutter-CDN   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["CocoaPods"],"categories":["iOS"]},{"title":"GitHub 项目 README 展示使用本开源库的 App","url":"/2019/04/06/GitHub-ReadMe-Apps/","content":"\n## 零、前言\n\n1. 本文展示有引用关系的 App，所以仅针对 iOS / Android 库；\n2. 本文依赖 AppSight 的数据实现所述功能，若您的 SDK 无法在 AppSight 检索到，则本文方式无法使用。\n\n## 一、找到源数据\n\n展示使用某库的 App，首先需要找到一个能够提供相应数据的数据源，这里我们依赖的 [AppSight](https://www.appsight.io)，这里以 [EFCountingLabel](https://github.com/EFPrefix/EFCountingLabel) 为例，我们在 上找到它对应的页面 [https://www.appsight.io/sdk/ef-counting-label](https://www.appsight.io/sdk/ef-counting-label)，打开后可看到相关引用数据，如下所示：\n\n![](https://user-gold-cdn.xitu.io/2019/4/6/169f0f80e72751bc?w=1288&h=917&f=png&s=200364)\n\n## 二、加载所有数据\n\n数据有了，接下来我们可以用脚本爬取的方式获取想要的数据，这里为了便于调试，笔者使用了 JavaScript，在 Chrome 的 Console 里执行就可以直接获取我们想要的结果。\n\n由于此处的引用数据是有分页的，那么爬取之前，我们先要写一段脚本来循环点击分页加载按钮，帮助我们自动加载所有的分页数据（如果数据量少的话意义不是很大，但是数据量多的话，这一步就很有必要了）。\n\n在 SDK 页面，打开 Chrome 开发者工具中的 `JavaScript 控制台`，执行如下脚本即可：\n\n```javascript\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nasync function main() {\n\tvar using = document.getElementsByClassName('as-sec-apps-using')[0];\n\tdo {\n\t\tif (document.getElementsByClassName('as-sec-loading')[0].style.cssText == \"display: block;\") {\n\t\t\tawait sleep(1000);\n\t\t} else {\n\t\t\tif (using.getElementsByClassName('as-but as-but-more btn disabled')[0] == null) {\n\t\t\t\tusing.getElementsByClassName('as-but as-but-more btn')[0].click();\n\t\t\t\tawait sleep(1000);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (true);\n}\nmain();\n```\n\n## 三、生成 HTML 代码\n\n所有分页数据加载完成（或者达到你需要的数量）后，继续在 `JavaScript 控制台`，执行如下脚本：\n\n```javascript\nvar using = document.getElementsByClassName('as-sec-apps-using')[0]\nvar items = using.getElementsByClassName('as-list-item-inner')\nvar result = \"<table><tr>\"\nfor(let i = 0, len = items.length; i < len; i++) {\n\tif(i % 10 == 0 && i > 0) {\n\t\tresult = result + \"</tr><tr>\"\n\t}\n    let item = items[i]\n    var icon = item.getElementsByClassName('as-icon')[0].src;\n    var title = item.getElementsByClassName('as-label as-name')[0].innerHTML;\n    var href = item.href\n    result = result + \"<td><a href=\\'\" + href + \"\\' title=\\'\" + title + \"\\'><img src=\\'\" + icon + \"\\'></a></td>\"\n}\nresult = result + \"</tr></table>\"\nconsole.log(result)\n```\n\n可以获得对应的 App 信息的 HTML 代码，如下所示：\n\n![](https://user-gold-cdn.xitu.io/2019/4/6/169f1408e10d6030?w=1767&h=741&f=png&s=445066)\n\n获得的代码整理后为如下形式：\n\n```html\n<table>\n  <tr>\n    <td>\n      <a href='https://www.appsight.io/app/toss-%ED%86%A0%EC%8A%A4' title='토스'>\n        <img src='https://d3ixtyf8ei2pcx.cloudfront.net/icons/001/263/485/media/small.png?1530945069'>\n      </a>\n    </td>\n    <td>\n      <a href='https://www.appsight.io/app/%EC%87%BC%ED%95%91%EC%9D%84-%EB%9A%9D%EB%94%B1-%ED%8B%B0%EB%AA%AC' title='티몬 - 오늘은 또 어떤 딜?'>\n        <img src='https://d3ixtyf8ei2pcx.cloudfront.net/icons/001/286/380/media/small.png?1534301992'>\n      </a>\n    </td>\n    <td>\n      <a href='https://www.appsight.io/app/%EB%B1%85%ED%81%AC%EC%83%90%EB%9F%AC%EB%93%9C' title='뱅크샐러드'>\n        <img src='https://d3ixtyf8ei2pcx.cloudfront.net/icons/001/282/332/media/small.png?1533591669'>\n      </a>\n    </td>\n    <td>\n      <a href='https://www.appsight.io/app/climendo-basic' title='Climendo Basic'>\n        <img src='https://d3ixtyf8ei2pcx.cloudfront.net/icons/000/304/533/media/small.png?1481531280'>\n      </a>\n    </td>\n  </tr>\n</table>\n```\n\n## 四、嵌入 README 中\n\n复制我们前面获得的 HTML 代码，直接插入到我们项目 README 的合适位置即可：\n\n![](https://user-gold-cdn.xitu.io/2019/4/6/169f1441fa3d0f42?w=1181&h=531&f=png&s=120336)\n\n## 五、效果展示\n\n最后实际效果如下，也可以点击直接查看 [EFCountingLabel 的 README](https://github.com/EFPrefix/EFCountingLabel/blob/master/README.md) 进行预览：\n\n![](https://user-gold-cdn.xitu.io/2019/4/6/169f144d8c360486?w=995&h=521&f=png&s=156267)\n\n感兴趣的同学，快自己动手试一试吧，👻\n\n---\n\n再读一篇类似文章？\n\n[GitHub Wiki 页面的添加和设置](https://www.eyrefree.org/2017/07/06/GitHub-Wiki-Introduction/)\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2019/04/06/GitHub-ReadMe-Apps/   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)\n","tags":["GitHub"],"categories":["Markdown"]},{"title":"怎样将信息发布 / 记录到 ETH 网络？","url":"/2018/07/25/ETHTransactionData/","content":"\n现在各行各业都在“上链”，大家说的“上链”到底是什么呢？今天，咱就来实际操作一把...\n\n---\n\n阅读本文前，请先确保您：\n\n1. 具备科学上网能力；   \n2. 有钱，能兑换成 ETH 虚拟币用来支付以太坊转账费手续费；   \n3. 有一定的英文阅读能力。\n\n---\n\n## 1. 下载 / 安装 Chrome\n\n下载谷歌浏览器并安装，官网地址：[https://www.google.com/intl/zh-CN_ALL/chrome/](https://www.google.com/intl/zh-CN_ALL/chrome/)\n\n![](https://upload-images.jianshu.io/upload_images/1018190-ebc9cd894d955ba7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2. 安装 MetaMask 插件\n\n打开 Chrome 网上应用店，下载 MetaMask 插件 [https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=zh-CN](https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=zh-CN)，这是一个运行在 ETH 网络上的 DAPP，感兴趣的同学可以研究一下它的源码：[https://github.com/MetaMask/metamask-extension](https://github.com/MetaMask/metamask-extension)。\n\n![](https://upload-images.jianshu.io/upload_images/1018190-31d82c6a4c6dd257.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后在 Chrome 内打开 MetaMask，左上角下拉列表可以选择网络类型，我们要用的是第一个 Main Ethereum Network（其他的都是测试网络...）：\n\n![](https://upload-images.jianshu.io/upload_images/1018190-5a971e2759060a55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 3. 注册 ETH 钱包\n\n接下来在 MetaMask 内根据提示注册 ETH 钱包（同时也会成为你的 MetaMask 账号），注意将公钥、私钥、助记词、密码之类的信息记录在可靠的地方，丢失的话，你的 ETH 钱包（主要是里面包含的虚拟币）就没啦。\n\n![](https://upload-images.jianshu.io/upload_images/1018190-0466beb4abcea283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 4. 给 ETH 账号打钱\n\n新建的 ETH 钱包是木有钱的，而接下来的我们发布信息的操作需要执行转账动作。有的同学可能会问，我们进行一笔总价为 0 ETH 的交易不就行了么？没错，这样的确可以不产生实际的虚拟币转账，不过仍然需要手续费来驱使矿工们将这一笔为 0 的交易记录写入到区块内，也就是每一笔交易只有支付了手续费才有可能发生（手续费是交易发起者自定的，如果手续费过低，可能会出现交易失败）。\n\nETH 网络上用到的手续费肯定就是 ETH（以太坊）啦，来源的话，一般是去 [币安](https://www.binance.com/?ref=27965336)、[OTCBTC](https://otcbtc.com/referrals/EYREFREE) 之类的交易所购买然后从交易所提币到自己的钱包，过程比较繁琐，可以自行研究，这里不多做赘述。\n\n只是了解 / 试用一下，不打算大批量购买的话，找一个有 ETH 的朋友让他转你 0.01 ETH（现价大概 3208.36 * 0.01 = 32 RMB）一般就够用了...\n\n![](https://upload-images.jianshu.io/upload_images/1018190-e4207d8a72600521.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 5. 准备需要发布的信息\n\n接下来就是准备我们需要发布的信息啦，因为需要转码成 Hex String，所以直接试用中文大概是不资瓷的啦，需要先转成拼音，比如我们随便找一段文字，像这样：\n\n```\n烂是有原因的，[微笑]。大家都愿意吃屎，你不吃，就是你的过错了，[微笑]。***写得再烂，至少还愿意认错，[微笑]。****不止烂，还嘴硬，[微笑]\n```\n\n然后用 [汉字转拼音工具](https://www.chineseconverter.com/zh-cn/convert/chinese-to-pinyin) 转为拼音（注意全角标点符号要自己改成半角哦，然后风格大家可以自选...）：\n\n```\nlan4 shi4 you3 yuan2 yin1 di2 , [ wei1 xiao4 ] . da4 jia1 du1 yuan4 yi4 chi1 shi3 , ni3 bu4 chi1 , jiu4 shi4 ni3 di2 guo4 cuo4 liao3 , [ wei1 xiao4 ] . * * * xie3 de2 zai4 lan4 , zhi4 shao3 huan2 yuan4 yi4 ren4 cuo4 , [ wei1 xiao4 ] . * * * * bu4 zhi3 lan4 , huan2 zui3 ying4 , [ wei1 xiao4 ] .\n```\n\n![](https://upload-images.jianshu.io/upload_images/1018190-a84204c59e10d4dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来再用 [String 转 Hex 工具](https://codebeautify.org/string-hex-converter) 转为 Hex String 即可：\n\n```\n6c616e34207368693420796f7533207975616e322079696e3120646932202c205b2077656931207869616f34205d202e20646134206a69613120647531207975616e342079693420636869312073686933202c206e6933206275342063686931202c206a6975342073686934206e6933206469322067756f342063756f34206c69616f33202c205b2077656931207869616f34205d202e202a202a202a207869653320646532207a616934206c616e34202c207a686934207368616f33206875616e32207975616e34207969342072656e342063756f34202c205b2077656931207869616f34205d202e202a202a202a202a20627534207a686933206c616e34202c206875616e32207a7569332079696e6734202c205b2077656931207869616f34205d202e\n```\n\n![](https://upload-images.jianshu.io/upload_images/1018190-96ba6002d9f3ab2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n最后可以用 [Hex 转 String 工具](https://codebeautify.org/hex-string-converter) 试试看能不能再转回来确认一下有无问题：\n\n![](https://upload-images.jianshu.io/upload_images/1018190-96390e6e4d7c14a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 6. 生成一笔交易记录\n\n然后我们继续回到 MetaMask，点击 SEND 按钮开始一笔转账：\n\n![](https://upload-images.jianshu.io/upload_images/1018190-ae93d36b52890b79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n随便填入一个有效的 ETH 接收地址，这里我用的是 0xa666b081583dbe8018af7c7c6e8bb6954c8984d2，然后交易数额填 0，TRANSACTION DATA 就填写刚才生成的 Hex String，然后点击 SEND 就行啦：\n\n![](https://upload-images.jianshu.io/upload_images/1018190-806b97ab28a7070b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来是交易确认界面，我们需要将 Gas Price 修改为 2，这样容易更快完成交易：\n\n![](https://upload-images.jianshu.io/upload_images/1018190-d094cb44fa8ebdb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后点击 SUBMIT 按钮即可，然后过一会就能在列表中看到这一条交易已完成啦：\n\n![](https://upload-images.jianshu.io/upload_images/1018190-4c47251c48893fd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击可以查看详情，比如这一条交易记录可以在这个页面进行查看：[https://etherscan.io/tx/0xff61b121aef8065e6e0a2aeeff5d9fce738b1ba0cbe5e1cd8b51b3509faff903](https://etherscan.io/tx/0xff61b121aef8065e6e0a2aeeff5d9fce738b1ba0cbe5e1cd8b51b3509faff903)，翻到下面详情中的 Input Data 选择以 UTF-8 方式预览即可：\n\n![](https://upload-images.jianshu.io/upload_images/1018190-409c6b0a8383e8a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后全球所有的 ETH 钱包这时应该都已经同步了这条信息啦，好玩吧，这，就是传说中的，上链。\n\n还不赶紧自己动手实践一下？​\n\n\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2018/07/25/ETHTransactionData   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["ETH"],"categories":["BlockChain"]},{"title":"蜂鸟商家版 iOS 组件化 / 模块化实践总结","url":"/2018/01/20/LPDBusinessiOS/","content":"\n![](https://user-gold-cdn.xitu.io/2018/1/19/1610f02b4af3f3d9?w=750&h=400&f=png&s=302366)\n\n## 零. 前言\n\n> “蜂鸟配送商家版”是一款针对商家打造的专业配送软件，有了这款应用，您可以使用蜂鸟商家版呼叫所有平台订单及电话订单配送，餐饮、鲜花、蛋糕、生鲜、商超均可配送。超低运费，清晰合理。海量补贴，充值返现。\n\n以上这段对「蜂鸟商家版」的描述摘自 [蜂鸟配送官网](https://fengniao.ele.me/business.html)，大概可以理解为蜂鸟商家版是一个给广大商家用来发单呼叫配送员的 App。许多同学可能只听说过「饿了么」外卖应用，但是对支撑起外卖配送的后勤业务「蜂鸟配送」却知之甚少，实际上每天海量的外卖订单都是由蜂鸟配送系统进行处理和配送最终送到消费者手中的。外卖 O2O 是由外卖平台、商户、配送系统这三方合作共同完成的，缺一不可。O2O 最核心的价值就是人与服务的连接，而这种连接最终都是通过配送才得以实现的。\n\n自 2016 年底开始我参与蜂鸟商家版的维护工作，除了日常的开发迭代以外，期间还参与推进了项目 Swift 化、项目组件化 / 模块化、非业务组件开源化等技术改造工作，今天这篇文章就给大家分享一下蜂鸟商家版 iOS 的组件化 / 模块化实践过程和自己的心得体会。\n\n## 一. 背景分析\n\n蜂鸟商家版 iOS 端代码使用 Git 进行管理，代码托管在内网的 GitLab 上。项目的依赖管理工具是大家比较熟悉的 CocoaPods，除了 RN 模块为了和 Android 组公用采用 Submodule 进行管理外，其他所有的子模块都采用 Pods 库的方式引入。\n\n### 1. 存在的问题\n\n在「蜂鸟商家版 iOS 组件化 / 模块化」工作开展之前，项目主要存在如下这些问题：\n\n- 项目臃肿不堪\n\n在组件化 / 模块化之前，蜂鸟商家版 App 的所有代码 / 资源文件等都是在同一个主工程里的，只有 RN 仓库或组内公用私有库等极少部分代码游离于主工程之外，所以在开发时，每一次都要编译整个项目的所有代码，十分低效。这个问题在独立开发时还不是十分明显，毕竟虽然项目大但是代码只有一个人在提交，所以项目代码量增加也不是那么夸张而且对项目发生的变化比较熟悉。但是当多人协作开发时，这个缺陷就暴露了出来，大家在各自开发不同的业务时，不仅要时刻和他人同步项目变化、读懂他人代码，还要每次编译完整个项目才能对自己所做的一点修改进行调试，效率低下。\n\n- 团队规模变化\n\n我开始参与蜂鸟商家版 iOS 端的维护时，之前只有一个前辈在维护，也就是一个人独立维护一个 App。然后过了没多久，他离职去了另一家公司，所以又变成了一个人独立维护这个 App。这时候因为是独立开发，所以也不存在什么太大的问题。但随着团队扩大，后面陆续来了几位同事共同负责这个项目的维护工作，大家都在同一个工程上进行业务开发，经常遇到如代码冲突、开发效率低下、职责划分不清、代码管理混乱等问题。\n\n- 业务发展压力\n\n由于公司处在高速发展的阶段，业务增长很快，最直观的表现就是市场 & 客服部门不断接到大量一线使用者的使用反馈或诉求，最后就变成了产品展示给我们开发人员的一份接一份的 PRD。紧凑的业务开发需求和各种灵活的功能迫使我们想尽一切能够使用的办法来提高开发效率，提高提测质量。\n\n- 代码管理混乱\n\n当我开始参与这个项目的维护时，这个项目就已经是一个 Swift 和 OC 混编的项目了，然后还有 RN 和 H5 代码，可以说是十分复杂了。虽然这不是我厂唯一一个 Swift 和 OC 的混编项目，但绝对是当时 Swift 化最高的一个项目，约 25% 的代码为 Swift。众所周知，Swift 和 OC 的互相调用远不如 Java 和 Kotlin 的互相调用那么顺滑（反正你现在知道了），并且处处藏着危机，暗坑无数，所以迫切需要找一个方式，将 Swift 和 OC 代码进行整理、转换或者分隔。毕竟，这个文件是 OC 下一个文件就是 Swift 这种频繁的思维转换在业务开发这种本就十分紧张的场景下，会使人十分疲惫，不利于开发工作的顺利进行。\n\n![](https://user-gold-cdn.xitu.io/2018/1/19/1610f02b4ad93d93?w=800&h=683&f=png&s=230419)\n\n### 2. 怎样去解决\n\n为了解决以上这些问题，我们曾经进行过如下一些探索：\n\n1. 移除无用的第三方库和资源文件，减少打包时间：效果不明显；\n2. 整理并推动内部 Gitflow 工作流，提高协作效率：有一些效果，但由于项目过大，日常协作仍然吃力；\n3. 研究 Swift 编译时间优化方法，提高编译效率：发现增加编译时间的都是 Swift 的一些常用语法糖，如果不用的话，严重降低开发效率，遂放弃；\n4. 在不拆分主工程的情况下，推动项目整个 Swift 化：由于之前维护项目的前辈离职，导致目前的项目开发人员都对原代码不是十分熟悉，不敢妄加改动，加之业务迭代频繁，开发和测试资源都十分紧张，该工作工作推进十分缓慢。\n\n可以发现上述尝试的结果都不是十分理想，在与 iOS 组内大佬们进行一些沟通，听取大佬们的意见后，决定对原项目进行「组件化 / 模块化拆分」工作，它能带来如下这些好处：\n\n- 加快编译速度，不用再编译组件 / 模块外没有被依赖到的代码；\n- 便于将每个模块指定给不同负责人进行管理；\n- 降低合并难度，减小冲突和出错概率，提高业务开发效率；\n- 将 Swift 和 OC 代码进行分离，便于进一步 Swift 化工作的推进；\n- 可为模块编写单元测试，提高工作效率，同时方便测试人员进行有针对性的测试。\n\n## 二. 目标设定\n\n- 功能组件独立：保证所有的底层功能组件从主工程抽出，独立与主工程之外，便于复用、业务模块的调用；\n- 业务模块划分与拆解：将业务按对应用途进行划分和拆解，想办法切断各业务之间的强依赖；\n- 所有组件 / 模块独立编译：所有功能组件和业务模块能够独立于主工程进行编译，有各自的 Demo 工程；\n- CocoaPods 发布：在内网 GitLab 进行发布，并且之后对每个模块用 GitFlow 工作流进行管理和后续发布工作。\n\n![](https://user-gold-cdn.xitu.io/2018/1/19/1610f02b4ae5935d?w=840&h=351&f=png&s=110856)\n\n## 三. 计划制定\n\n说到组件化 / 模块化，那么什么是组件化 / 模块化呢？组件化和模块化的区别又在哪里呢？\n\n组件，就是我们对功能的封装，一个功能就是一个组件，数据库、网络、文件操作、社会化分享等等这些功能都是组件。我们之所以要搞出组件的概念，是为了能够让我们的上层业务模块能够随时依赖和调用这些基础功能。组件基本上可以分为基础功能组件、通用 UI 组件、基础业务组件等这几类。所以为了满足上述要求，组件必须具有较高的独立性、扩展性以及复用性。\n\n模块，就是对一系列有内聚性的业务进行整理，将其与其它业务进行切割、拆分，从主工程或原所在位置抽离为一个相对独立的部分。仅仅针对业务而言，比如说我们可以把订单业务独立为为一个模块，可以把个人中心独立为一个模块，把用户登录独立为一个模块等，在 App 中的体现就是一个个独立的 Git 仓库。模块化的一个好处是用到时可以搭积木，比如可以多个工程间复用同一个或几个业务模块，比如腾讯的 QQ 和 TIM，除了 UI 界面外 TIM 显然复用了大量现有的原 QQ 工程的业务模块代码，当然，我们这里暂时并没有这个需求。\n\n经过小组会议讨论，我们的想法是将共用组件独立出来，然后直接按业务对现有主工程进行拆分同时兼顾 Swift 与 OC 分离，大致划分如下表所示：\n\n### 1. 组件\n\n| 组件 | 库名 | 主要内容 |\n|:---|:----|:----|\n|基础（OC）|LPDBOCFoundationGarbage| 基础的 OC 组件，各种零散的、混乱的视图、组件、控件、常量、OC 宏定义等，全放在这里，供上层调用。和他的库名一样，其本质就大概就是个垃圾桶。 |\n|基础（Swift）|LPDBPublicModule| 基础的 Swift 组件，包含一些公用的 Swift 扩展，和模块间解耦的协议。 |\n|网络（OC）|LPDBNetwork| 网络组件，对 AFNetworking 的浅层封装，同时包含了和网络相关的业务功能。 |\n|...|...|...|\n\n### 2. 模块\n\n| 模块 | 库名 | 主要内容 |\n|:---|:----|:----|\n|历史（OC）|LPDBHistoryModule| 历史订单模块，包含和历史订单相关的资源文件、UI、业务逻辑代码等。|\n|登录（OC）|LPDBLoginModule|用户登录模块，包含和登录、注册页面相关的资源文件、UI、业务逻辑代码等。|\n|用户中心（OC）| LPDBUserCenterModule | 用户中心模块，包含和用户个人中心以及状态相关的资源文件、UI、业务逻辑代码等。|\n|...|...|...|\n\n### 3. 关系\n\n按照上面的思路，理想化的模块 / 组件依赖关系图大概是这个样子的：\n\n![](https://user-gold-cdn.xitu.io/2018/1/19/1610f02b4a9c953e?w=548&h=272&f=png&s=22346)\n\n因为蜂鸟商家版的团队开发人员之前均没有过任何项目的拆分经验，大家也都是摸着石头过河，走一步看一步。所以虽然以上的拆分思路总体是对的，先拆组件后拆业务，但由于各种各样的原因，一些问题就在接下来的工作实施过程中暴露了出来。\n\n## 四. 工作实施\n\n我们小组主要还是以业务开发为主，所以组件化 / 模块化工作都是大家抽空闲时间来完成，并没有进行硬性的排期和设置 Deadline。按照之前制定的计划，我们进行了以下这些工作：\n\n### 1. 功能组件独立\n\n#### 1.1 LPDBOCFoundationGarbage\n\nLPDBOCFoundationGarbage 是我们项目最先抽出的部分，这个库将和 LPDBPublicModule 一起，作为整个工程的最底层，再往下就是。这个库的定位和它的名字一样，就是一个垃圾桶，啥都往里放。其中大致包含以下一些东西：\n\n- 自定义的 View 和控件，例如：小红点控件、刷新控件、加载控件、Tips 视图等；\n- 自定义的 Controller，例如：基础控制器 BaseViewController、WebView 基础控制器 BaseWebViewController、自定义的弹框 AlertController等；\n- 和业务相关的对基本类型或系统控件的扩展：对 NSObject、UIButton、UIImageView、UILabel 等添加的扩展代码 category；\n- 甚至版本控制模块 LPDBVersionManager 也放在了这里。\n\n因为我们在进行拆分任务的同时，还在同时维持着项目的开发工作，所以我们暂时没有精力做细致的拆分工作，只能先把这些零散的部分先放在一起进行管理。\n\n#### 1.2 LPDBPublicModule\n\nLPDBPublicModule 是基础的 Swift 组件，这个库主要包含：\n\n- 一些公用的 Swift 扩展，例如：对 CGFloat、Date、NSString 等系统类型的 extension；\n- 用于模块间解耦的协议。\n\n因为工程内的 Swift 代码大多是我们新写的，所以相对旧的 OC 代码而言，整理地更好一些，所以这个仓库干净很多\n\n#### 1.3 LPDBNetwork\n\nLPDBNetwork 网络组件是我们项目完成 OC 和 Swift 基础部分后最先抽出的部分，刚开始我们认为这部分仅仅是单纯的业务网络请求操作和对 AFNetworking 的浅层封装，不包含界面 UI 逻辑等。不过当我们拆解完成后，发现其中还包含了一堆奇怪的东西：\n\n- 对 AFNetworking 的封装和网络操作的一些定义，例如：LPDBHttpManager、LPDBRequestObject 和 LPDBModel 等；\n- UI 操作，例如：等待视图 LPDBLoadingView 和 网络请求失败的提示等。\n\n这一部分的话，因为都是比较古老的代码，所以当初的开发人员都已经不再继续维护了，所以在只能是我们自己进行拆分的情况下，为了防止大的变更导致发生问题，所以没有对这一块进行更细致的拆解工作。毕竟再烂代码也比不能工作的代码要好。\n\n#### 1.4 LPDBUIKit\n\nSwift 的 UI 库，我们将工程中的一些 Swift 视图和控件收集到了这个项目中，主要包含以下这些内容：\n\n- 视图，例如：LPDBEmptyDataView、SlideScrollView 等；\n- 控件，例如：SlideTabKit 等。\n\n因为 Swift 代码总量还不是很大，所以这个库的东西目前也不是很多，以后会逐渐丰富起来。\n\n### 2. 业务模块拆分\n\n完成了上面的组件库的独立工作后，业务模块的拆解就相对轻松一些了，目前我们主要完成了三个业务模块的拆分工作。\n\n#### 2.1 LPDBHistoryModule\n\nLPDBHistoryModule 历史订单模块，和历史订单页面相关的信息都在该模块中，主要包含以下内容：\n\n- UI，例如：历史订单界面、历史订单列表 Cell、加载视图等；\n- 数据模型，例如：历史订单模型；\n- 历史订单列表相关的网络请求。\n\n因为该模块相对来说比较独立，所以拆分过程也比较顺利，主要依赖了 LPDBPublicModule、LPDBNetwork、LPDBOCFoundationGarbage 组件。\n\n#### 2.2 LPDBLoginModule\n\nLPDBLoginModule 用户登录模块是一个与用户登录、注册以及用户登录信息有关的模块，主要包含了以下信息：\n\n- UI，例如：用户登录界面、用户注册界面等；\n- 数据模型，例如：用户信息模型、用户信息地址模型等；\n- 登录与注册相关的网络请求。\n\n该模块相比较历史订单模块复杂了一些，不过仍然比较顺利，主要依赖了 LPDBPublicModule、LPDBOCFoundationGarbage、LPDBNetwork 组件。\n\n#### 2.3 LPDBUserCenterModule\n\nLPDBUserCenterModule 用户中心模块是一个与用户个人中心以及用户信息修改有关的模块，主要包含了以下信息：\n\n- UI，例如：用户中心界面、用户电话修改界面、用户密码修改界面等；\n- 数据模型，例如：用户详细信息模型、用户信息地址模型等；\n- 用户中心相关的网络请求，例如：修改电话号码、请求验证码等。\n\n该模块主要依赖了 LPDBOCFoundationGarbage 组件和 LPDBLoginModule 模块。\n\n#### 2.4 其它\n\n剩下的其他一些模块仍然处于计划中的状态，暂未进行拆分。到这一步的话，库间依赖关系大致如下图所示：\n\n![](https://user-gold-cdn.xitu.io/2018/1/19/1610f02b4a8c0fca?w=1240&h=608&f=png&s=111714)\n\n可以看到其中存在一些不太合理的依赖关系，如 LPDBUserCenterModule 依赖 LPDBLoginModule 模块，也就是所谓的业务模块横向依赖问题，接下来，我们就要处理这一问题。\n\n### 3. 解除耦合\n\n由于之前开发过程中从未有过任何模块化的考量，所以蜂鸟商家版的代码非常杂糅，项目依赖关系十分复杂，主要可以分为以下三类耦合：\n\n- 界面耦合：App 执行过程中，硬编码的界面间的跳转行为；\n- 工程耦合：某些模块在运行时需要依赖主工程的代码才能运行或实现完整的功能；\n- 依赖耦合：两个业务模块之间的有依赖。\n\n#### 3.1 模块间组件共用\n\n在拆分业务模块的过程中，经常发生两个业务模块同时引用某一块业务代码的问题，这时我们就需要对这一块代码进行理解，首先区分它到底应不应该划分到业务层来？\n\n- 如果是的话，应该划归到哪一个模块中去更合理一些；\n- 如果不是的话，应该将这一部分代码下沉到哪一个组件库中去比较合适，或者独立为一个组件。\n\n在 LPDBUserCenterModule 的抽离过程中就遇到了这个问题，LPDBUserCenterModule \n 和 LPDBLoginModule 共同依赖了几个和用户信息有关的数据模型，导致需要发生模块间横向依赖，所以我们将共用的数据模型抽出，然后下沉到了 LPDBOCFoundationGarbage 中。\n\n#### 3.2 模块间耦合\n\n另一个经常遇到的问题就是跨模块调用代码的问题了，不仅是模块与模块间代码的互相调用、模块间页面的跳转，还有模块反向调用主工程代码等问题，这个问题的解决我们分了三步：\n\n- 反射调用\n\n因为工程的复杂性和以前代码的不规范，导致我们在处理切割业务模块时比较痛苦，所以我们在刚开始抽出模块时采用了一种快速但不太安全的方式进行解耦，比如在 LPDBUserCenterModule 模块中需要调用主工程的 getMiddlePageVC 方法时，我们用了如下临时解决方案：\n\n```objc\nif ([[UIApplication sharedApplication].delegate respondsToSelector:@selector(getMiddlePageVC)]) {\n    UIViewController *info = [[UIApplication sharedApplication].delegate performSelector:@selector(getMiddlePageVC)];\n\n    ...\n}\n```\n\n然后在主工程的 中实现这个接口：\n\n```objc\n// .h\n@interface AppDelegate : UIResponder <UIApplicationDelegate>\n\n...\n// LPDBUserCenterModule\n- (UIViewController *)getMiddlePageVC;\n\n...\n\n@end\n\n// .m\n@implementation AppDelegate\n\n...\n\n- (UIViewController *)getMiddlePageVC {\n    ...\n\n    return xxx;\n}\n\n...\n\n@end\n```\n\n这一方案的优点就是灵活，利用 NSClassFromString、performSelector 等方式，能够快速解决各种耦合问题，瞬间切割出模块。但缺点也显而易见，字符串硬编码，维护成本大，去掉了编译器检查，容易翻车。\n\n- 协议调用\n\n所以自然而言地，当我们的某个业务模块的拆分工作基本定型时，我们就开始将第一步中的反射调用方式替换为协议的方式进行调用，比如当 LPDBLoginModule 模块需要调用主工程的 getCoordinate 方法时，示例如下：\n\n```objc\nid delegate = [[UIApplication sharedApplication] delegate];\n\nif (![delegate conformsToProtocol:@protocol(AppDelegateProtocol)]) {\n    return;\n}\nCLLocationCoordinate2D coordinate = [delegate coordinate];\n```\n\n然后在主工程中实现该方法：\n\n```objc\n// .h\n#import \"AppDelegate.h\"\n\n@import LPDBLoginModule;\n\n@interface AppDelegate (Protocol)  <AppDelegateProtocol>\n\n@end\n\n// .m\n@implementation AppDelegate (Protocol)\n\n- (CLLocationCoordinate2D)getCoordinate {\n    return self.coordinate;\n}\n\n@end\n```\n\n但是，样的改变并不能彻底解决所编写的模块间互相调用的代码缺乏编译器检查的问题，而仅仅是对调用方做了判断加上了容错，并不能在编译期就让开发人员察觉到问题，一定要进行测试才可以，所以这种方式也不是十分理想。\n\n- Lotusoot 解耦工具\n\n那么为了彻底解决问题，我们开发和引入了组件通信和工具 Lotusoot，调用方式有下列几种可供参考：\n\n- 服务调用\n\n```swift\nlet lotus = s(AccountLotus.self) \nlet accountModule: AccountLotus = LotusootCoordinator.lotusoot(lotus: lotus) as! AccountLotus\naccountModule.login(username: \"admin\", password: \"wow\") { (error) in\n    print(error ?? \"\")\n}\n```\n\n- 短链注册\n\n```swift\nlet error: NSError? = LotusootRouter.register(route: \"newproj://account/login\") { (lotusootURL) in\n    accountModule.showLoginVC(username: \"admin\", password: \"wow\")\n}\n```\n\n- 短链调用\n\n```swift\nlet param: Dictionary = [\"username\" : \"admin\",\n                                 \"password\" : \"wow\"]\n\n// 无回调                                 \nLotusootRouter.open(route: \"newproj://account/login\", params: param)\n// 有回调\nLotusootRouter.open(route: \"newproj://account/login\", params: param).completion { (error) in\n    print(error ?? \"open success\")\n}\n// ⚠️不推荐的用法，用 ?pram0=xxx 这样的形式导致字符串散落在各处，不易管理。\n// 但为了保证 Hybrid 项目中 H5 页面的正常跳转，提供了此种调用\nLotusootRouter.open(url: \"newproj://account/login?username=zhoulingyu\").completion { (error) in\n    print(error ?? \"open success\")\n}\n```\n\n具体可以参见 [iOS 灵活的 模块化/组件化 工具与规范 Lotusoot 解说](http://zhoulingyu.com/2017/11/29/iOS-modularized-tool-Lotusoot/) 一文，在此不多做赘述。类似的工具还有 [BeeHive](https://github.com/alibaba/BeeHive) 和 [LPDMvvmRouterKit](https://github.com/LPD-iOS/LPDMvvmRouterKit) 等，大家可以自行进一步探索。\n\n最终结构就变成了如图所示的样子：\n\n![](https://user-gold-cdn.xitu.io/2018/1/19/1610f02b4aa60211?w=708&h=408&f=png&s=44455)\n\n\n## 五. 问题整理\n\n### 1. 不合理的分层结构和库间依赖\n\n由于参与拆分工作的人员比较缺乏组件化经验，所以导致某些库的拆分不是十分合理，某些应该沉入底层的公用 Model 和常量等没有在开始时就放到一个合理的位置。业务模块之间也存在一些不合理的横向依赖，没有进行一个合理的业务边界划分。这些原因导致我们在进行拆分工作时经常需要回过头来对已经拆出来的模块和组件重新进行整理和处理，重复劳动量很大。\n\n### 2. 拆分粒度不适中\n\n某些库比如 LPDBOCFoundationGarbage 比较庞大，而像 LPDBUIKit 这样的库中内容却非常少，这一点的处理上存在问题。如果一个拆分完成的库仍然比较臃肿的化，说明仍然存在细化拆分的必余地。\n\n### 3. 工作进度难以控制\n\n由于没有能提前制定好详细的进度计划表，加上业务工作的挤压，导致我们花在组件化 / 模块化工作上的时间比较零散。本意是希望大家能够灵活安排工作，合理处置业务开发与技术改造工作之间的关系，但效果不是很理想，表现就是组件化 / 模块化工作的进行没有连续性，大家的积极性和工作效率也都不高。\n\n## 六. 经验总结\n\n### 1. 工作开始前要进行技术调研\n\n查看和学习一些同类成功的案例资料或者向业内大佬们请教能够对计划的制定带来便利，能够使我们避免很多错误的设计，少走一些弯路，降低返工率。\n\n### 2. 制定详细整体规划\n\n> 在准备作战时，我常常发现定好的计划没有用处，但计划的过程仍必不可少。—— 德怀特·艾森豪威尔\n\n制定详细的整体规划能够在设计阶段就将一些不合理的地方暴露出来，从而拿出解决方案使问题提前得到解决，或者把不合理的内容删减替换掉，例如分层不合理、库间依赖这样的问题，就会减少很多。拿出细致的任务拆分计划和工作量预估，也能更合理地将任务安排到开发人员手中，在提升工作效率的同时也能尽量避免和业务开发产生冲突。\n\n### 3. 注意对代码质量的控制\n\n好的代码和编码习惯能够大幅提升项目的可维护性，为之后的工作带来便利。我们之前旧的 OC 代码比较混乱，基本处于无法维护的状态，拆分起来十分痛苦；而新写的 Swift 代码明显质量要高很多（这真的不是我们自夸...），拆分起来就顺利多了。\n\n### 4. 重视信息的文档化\n\n每一个拆分出的模块及时添加文档，嫌麻烦的话至少要建立一份通用的 README 模板，每一个模块或组件的建立者把模块内容、拆分目的、设计思路等基本信息记录一下，有什么坑或者注意点也可以文档化，是以后的长期项目维护成为可能。\n\n## 七. 开源成果\n\n我们在组件化 / 模块化工作期间，产出的一些库和工具放在了 GitHub 上进行开源，给大家一些借鉴的同时，也希望能够收到大家的意见和建议，提高我们项目本身的质量：\n\n| 库名 | 简介 | 仓库地址 |\n|:-----|:-----|:---------|\n| Lotusoot | 灵活的 Swift 组件解耦和通信工具 | [https://github.com/Vegetarians/Lotusoot](https://github.com/Vegetarians/Lotusoot) |\n| Bamboots | 一个面向协议的 Swift 网络库 | [https://github.com/mmoaay/Bamboots](https://github.com/mmoaay/Bamboots) |\n| bigkeeper | 一个 iOS & Android 模块化项目效率提升工具 | [https://github.com/BigKeeper/bigkeeper](https://github.com/BigKeeper/bigkeeper) |\n| SideNavigation | 一个支持侧滑且可自定义的侧边栏 | [https://github.com/CNKCQ/SideNavigation](https://github.com/CNKCQ/SideNavigation) |\n| ViewPagers | 一个支持手势的 Segmented Control | [https://github.com/CNKCQ/ViewPagers](https://github.com/CNKCQ/ViewPagers) |\n| EFAutoScrollLabel | 一个带跑马灯效果的 UILabel | [https://github.com/EyreFree/EFAutoScrollLabel](https://github.com/EyreFree/EFAutoScrollLabel) |\n\n## 八. 后记\n\n本文基本描述了蜂鸟商家版 App 到目前为止的组件化 / 模块化实践情况，希望本文能够给您的移动项目演进提供一些借鉴。在此过程中我们产出的一些文章、开源库和工具，也希望能给大家带来一定的帮助或者启发。欢迎大家提出各种反馈和建议或，帮助我们继续改进和提高。\n\n2017 年底，也就是差不多我参与蜂鸟商家版的维护工作满一年的样子，由于业务调整的原因这个 App 已经移交给别的团队进行维护了，导致项目的 Swift 化和组件化 / 模块化工作并没有全部完成，这一点有些遗憾。不过还是希望蜂鸟商家版能够越来越好，继续为广大商家朋友们服务。\n\n好消息是，接下来我主要参与蜂鸟团队版 App 的架构工作，这一次我们根据之前暴露出的问题制定了详细的工作计划，有了蜂鸟商家版的踩坑经验后，我相信这一次我们一定能顺利完成目标。2018，加油，一起拼！\n\n本文编写过程中参考了以下文章，在此对原作者们表示感谢：\n\n1. [即时配送网之于外卖O2O，配送的更高境界是社群经营](https://36kr.com/p/5100487.html)\n2. [谈谈我的理解-组件化/模块化](https://www.jianshu.com/p/79e4df63f31f)\n3. [蘑菇街 App 的组件化之路](http://limboy.me/tech/2016/03/10/mgj-components.html)\n4. [豆瓣App的模块化实践](http://lincode.github.io/Modularity)\n5. [手机天猫解耦之路](http://www.infoq.com/cn/articles/the-road-of-mobile-tmall-decoupling)\n6. [京东iOS客户端组件管理实践](http://www.infoq.com/cn/articles/jd-ios-component-management)\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2018/01/20/LPDBusinessiOS   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。\n","tags":["Swift"],"categories":["iOS"]},{"title":"Git 踩坑：Git Push 远端无分支不提示","url":"/2017/12/25/Git-Push/","content":"\n上周遇到一个 Git 配置导致的问题，踩坑过程如下。\n\n## 一. 问题描述\n\n1. 首先找一个远端 Git 仓库，clone 到本地；\n2. 在本地新建一个分支 test（名字随意，只要远端不存在这个分支即可）并切换到该分支；\n3. 执行 `git push` 命令后会发现终端显示了 `Everything up-to-date`，会让人误以为该分支成功推到了远端；\n4. 实际上问题已经出现了，这里 `git push` 指令并没有正确提示我们远端不存在该分支。我们可以检查一下远端 Git 仓库，的确没有把 test 分支推上去；\n\n![](https://user-gold-cdn.xitu.io/2017/12/25/1608c4ec3e087cf1?w=585&h=366&f=png&s=55199)\n\n5. 这个问题有多坑呢？假设没察觉这里回显不对，而是把本地分支删了干别的去了，估计就哭了。\n\n## 二. 问题解决\n\n1. 查了 N 多资料；\n2. 对比了 N 多类似案例；\n3. 耗费了无数脑细胞；\n4. 终于在 [TimothyQiu](http://timothyqiu.com/) 大大告诉我解决方法之后解决了该问题，😂；\n5. 问题原因大概是因为 `gitconfig` 中的 参数设置异常导致的，我们可以执行 `git config -l`  命令查看当前的 Git 配置，可以看到 `push.default` 的值为 `matching`：\n\n![](https://user-gold-cdn.xitu.io/2017/12/25/1608c4ec3c4f77f6?w=805&h=381&f=png&s=63849)\n\n6. 用 `git config --global push.default simple` 命令把它改成 `simple` 即可：\n\n![](https://user-gold-cdn.xitu.io/2017/12/25/1608c4ec3c565841?w=804&h=396&f=png&s=69369)\n\n7. 然后执行 `git push` 命令就可以正常获取错误提示信息啦：\n\n![](https://user-gold-cdn.xitu.io/2017/12/25/1608c4ec3c6b61bd?w=518&h=103&f=png&s=11300)\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2017/12/25/Git-Push   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Git"],"categories":["Git"]},{"title":"利用 CodeBeat 为你在 GitHub 上的项目进行代码质量管理","url":"/2017/12/13/CodeBeat-GitHub/","content":"\nCodeBeat 是一个免费为开源项目进行代码质量管理的工具（付费可以支持私有项目），目前已经支持的编程语言有 Swift、Objective-C、Go、Ruby、Python、Java、Kotlin、Javascript、Typescript、Elixir，无需对原有项目进行任何修改即可获取针对项目的完整质量分析，方便快捷。\n\n## 前言\n\n当我们在 GitHub 上的代码仓库发生变更后，会通知 CodeBeat 执行分析操作刷新项目代码质量评分，并在完成后刷新项目评级 / 评分的状态或结果，如图所示：\n\n![代码质量效果预览](https://user-gold-cdn.xitu.io/2017/12/13/1604ec0b248e6fda?w=1184&h=673&f=png&s=98888)\n\nCodeBeat 的同类产品有 Code Climate，目前支持 Ruby、Python、PHP、JavaScript、Java、TypeScript，不过官网显示\n Swift、Go、Objective-C 的支持在计划中，因为我是 iOS 开发，所以暂时用不了这个，在一个 [Ruby 项目](https://github.com/BigKeeper/bigstash)有试过这个，看起来还好，有兴趣的同学也可以一试。\n\n本文以 [EFQRCode](https://github.com/EyreFree/EFQRCode)(一个使用 Swift 作为开发语言的二维码库) 为例，简述怎样为自己的开源项目添加代码质量管理功能。\n\n## 1. 注册 CodeBeat 账号\n\n打开 [https://codebeat.co/](https://codebeat.co/) 注册一个 CodeBeat 账号，也可以通过 GitHub 账户直接登陆。CodeBeat 服务对开源项目是免费的，所以你的私有项目无法享受到免费的持续构建服务。唔，当然，每月支付 20 美刀成为付费用户后可以解锁无限数量私有库的功能。\n\n## 2. 从 GitHub 添加项目\n\n登陆完成后，点击右边的 `Add Repository` 按钮即可开始添加自己的 Git 仓库，支持各种 Git 托管平台，甚至自建的也可以：\n\n![Add Repository](https://user-gold-cdn.xitu.io/2017/12/13/1604ec0b27e29b81?w=1168&h=411&f=png&s=35896)\n\n## 3. 开启代码质量管理\n\n第一次项目导入后会立即进行一次分析，试了一下速度还是比较快的（反正比持续集成快多了），反正我的项目导入以后刷新一下页面就出结果了。\n\n![](https://user-gold-cdn.xitu.io/2017/12/13/1604ec0b27f26013?w=1145&h=493&f=png&s=54810)\n\n唔，细心的同学可能会发现，这一步操作完成后我们在 GitHub 项目 Setting 中的 `Webhooks` 已经添加了一个属于 `codebeat.co` 的 Webhook，没错，以后项目代码发生更改后就会自动触发代码质量分析，不需要我们手动操作了。感兴趣的同学可以点击 `Edit` 按钮查看一下 CodeBeat 具体干了啥：\n\n![Webhooks](https://user-gold-cdn.xitu.io/2017/12/13/1604ec0b294a4d04?w=916&h=360&f=png&s=77638)\n\n关于 Webhook 感兴趣的同学可以查看 GitHub 官方的资料：[https://developer.github.com/webhooks/](https://developer.github.com/webhooks/)。\n\n## 4. 查看代码质量分析结果\n\n点击进入该项目的分析结果，可以查看到具体的问题，如代码复杂性、代码风格、代码重复等，点击 `Quick Wins` 这一栏可以查看优先推荐修复的项目，如下图所示：\n\n![](https://user-gold-cdn.xitu.io/2017/12/13/1604ec0b2da5c683?w=1162&h=401&f=png&s=70133)\n\n我们可以对应分析出的代码质量问题对我们的工程代码进行修改，改完直接提交到仓库即可，Webhook 会通知 CodeBeat 进行刷新。\n\n## 没了\n\n在  的项目设置中可以看到更多有意思的玩法，比如将代码质量变化通知发送到 Slack 或邮箱等，也可以将代码质量评级徽标添加到自己的项目 README 中，大佬们可以自行研究...\n\n![Setting](https://user-gold-cdn.xitu.io/2017/12/13/1604ec0b2d2ad569?w=1148&h=340&f=png&s=35402)\n\n祝操作顺利，🌈\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2017/12/13/CodeBeat-GitHub   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["CodeBeat"],"categories":["GitHub"]},{"title":"AppStore 审核 macOS 应用踩坑记录","url":"/2017/12/12/AppStore-macOS/","content":"\n## 1. Guideline 2.3.8 - Performance\n\n```\nGuideline 2.3.8 - Performance\n\nWe noticed that your app name to be displayed on the App Store does not sufficiently match the name of the app displayed when installed on macOS.\n\niTunes Connect Name: EFQRCode\n\nApp Name when Installed: EFQRCode.macos\n\nApp Name when Launched: EFQRCode\n\nApp Name in About/Quit Menu: macOS Example\n```\n\n大概是说 AppStore 的应用名称和 App 安装后以及 App 内的菜单项目上显示的不符，需要修改每一处到一样后重新打包提交。\n\niTunes Connect Name：编辑 iTunes Connect 的 App 信息中 App 名称可更改；\nApp Name when Installed：编辑 Build Setting 中的 Product Name 可更改；\n\n## 2. Guideline 5.2.5 - Legal\n\n```\nGuideline 5.2.5 - Legal\n\nYour app uses ‘macOS’ in the Installed App Name and Menu Item Names in a manner that is not consistent with Apple's trademark guidelines.\n\nIndicating Mac compatibility in the app name is not necessary for the Mac App Store.\n```\n\n这条意思是 App 中不应该出现 ‘macOS’ 等不符合苹果商标指南的字样，全局搜索，把不合法的文字出现从按钮 / 菜单 / 页面去除即可。\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2017/12/12/AppStore-macOS   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["macOS"],"categories":["AppStore"]},{"title":"如何将 CocoaPods 库升级到 Swift 4","url":"/2017/12/05/CocoaPods-Swift4/","content":"\n## 零. 前言\n\nSwift 版本升级嘛，大家应该都很熟练了，菜单 -> Edit -> Convert -> To Current Swift Syntax...，然后巴拉巴拉一顿操作。emmmn，抱歉，编译过了也不一定能正常使用。\n\n这次 Swift 3 到 Swift 4 的更新和之前的大版本更新相比，已经平滑了很多，相较之前的动辄几百上千个 error，现在用 Xcode 进行 Convert 之后基本上只需要进行少量人工修正即可，不过仍然有一些点需要注意，本文将会对一些常见的坑或者注意点以及解决方法进行讨论。\n\n本文以 [EFCountingLabel](https://github.com/EyreFree/EFCountingLabel) 的 1.0.3 版本和 Xcode 9.0 为例，主要关于原有的 Swift 3 的 CocoaPods 库到 Swift 4 的升级，仍处于 Swift 2 阶段的同学可暂时忽略本文。\n\n## 一. 升级流程\n\n### 1. 查看当前版本\n\n首先用 Xcode 打开工程，看一下当前工程设置的 Swift 版本，如果过低的话可能无法直接 Convert，选中需要转换的 target 搜索 `swift_ver` 即可，如图所示：\n\n![](http://upload-images.jianshu.io/upload_images/1018190-51f2abcb6ffc474c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里 EFCountingLabel 的 Swift 版本为 3.2，如果是 2.x 的话需要自己想办法先转换成 Swift 3.x...\n\n### 2. Xcode 代码转换\n\n接下来，就是利用 Xcode 实现代码转换了，菜单 -> Edit -> Convert -> To Current Swift Syntax...，然后选中需要转换的 target，点击 `Next` 按钮即可：\n\n![](http://upload-images.jianshu.io/upload_images/1018190-7235c3b6ddb5f4fe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 3. 选择转换模式\n\n然后会出现一个转换模式选项，有 `Minimize Inference（recommended）` 和 `Match Swift 3 Behavior` 两个选择，苹果推荐的是第一个选项：\n\n![](http://upload-images.jianshu.io/upload_images/1018190-d603752b86a67dd9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n苹果官方文档对这两个选项的描述如下，大意是：如果选第一个选项，会仅在必要的时候为方法或属性添加 `@objc` 标志，不过大部分工作需要用户（也就是你）手动完成，好处是能减少最终生成的二进制文件的大小；如果选择第二个选项，则会按 Swift 3 的方式给所有的地方直接添加 `@objc` 标志（关于 `@objc` 标志的介绍大家可以参考 Swift 翻译组的[这篇文章](http://swift.gg/2016/04/20/swift-qa-2016-04-20/)），缺点就是不会对生成的二进制文件大小进行优化（也就是跟 Swift 3 一样）：\n\n![](http://upload-images.jianshu.io/upload_images/1018190-0565c3371c173e78.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里我们分几种情况：\n\n1. 如果你的 Swift 库不打算支持 OC 调用的话，选 `Minimize Inference（recommended）`，检查并且保存自动转换结果即可，然后可以直接跳到下一小节，请忽略下面这一大段；\n2. 如果你的 Swift 库打算支持 OC 调用，但是开发时间紧迫暂时没时间仔细设置 `@objc` 标志或者对这一点二进制文件体积的缩减并不是十分在意的话，选 `Match Swift 3 Behavior`，检查并且保存自动转换结果即可，然后可以直接跳到下一小节，请忽略下面这一大段；\n3. 如果你的 Swift 库打算支持 OC 调用，并且打算用推荐的方式进行优化的话，选 `Minimize Inference（recommended）`，保存更改，然后按下面的操作去做：\n\n```\n1. 编译工程；\n2. 修正那些提示你需要添加 @objc 标志的警告（请务必修正，不然即使编译能过运行时也可能会出问题）；\n3. 修正 Xcode 提示的不需要添加 @objc 标志的代码，持续构建和测试你的代码，直到没有任何警告出现；\n4. 打开工程设置；\n5. 选中 target，搜索 `@objc` 找到 `Swift 3 @objc Inference` 选项，设为 `Default`。\n```\n\n唔，以上这段大概是原文翻译过来的了，官方文档原文如图所示：\n\n![](http://upload-images.jianshu.io/upload_images/1018190-57b6b30c33b54e1f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n需要注意的是，因为我们这里针对的并不是完整的 iOS 项目，而是 CocoaPods 库，如果你的 OC Demo 没有调用库中需要暴露的功能（或者干脆没有 OC Demo），辣么编译器可能完全不会给你任何提示而是直接通过编译了，直到你某一天在一个 OC 工程中引入这个库才会发现并不能调用到某些方法或获取某些属性。\n\n所以其实麻烦之处在于，编译器并不会给你任何提示，因为编译器也不知道哪些类 / 属性 / 方法需要暴露，哪些需要被优化掉，需要开发人员自己决定并手动添加对应的 `@objc` 标志，总结起来的话有以下几点：\n\n1. 需要在 OC 中调用一个 Swift 4 的类，需要让这个类继承 NSObject 并且在这个类前加上 @objc 标志；\n2. 需要在 OC 中调用一个 Swift 4 类的方法，需要在方法前加上 @objc 标志（这里有一个坑，如果是普通的函数调用还好，至少编译器会报错，如果是用 `#selector` 的方式调用的话，能过编译并且在运行时直接找不到对应方法而闪退，建议升完 Swift 4 检查一下所有的 #selector 调用）；\n3. 需要在 OC 中访问一个 Swift 4 类的某个属性，需要在属性前加上 @objc 标志（同上，如果是普通属性访问的话编译器会报错，但是 KVC 的话会在运行时找不到属性而崩溃，记得检查...）；\n4. 需要在 OC 中访问一个 Swift 4 类的扩展，只要在扩展前加上 @objc 标志，该扩展的属性和方法就都能被调用了。\n\n### 4. 更新 Xcode 设置\n\n1. 如下图所示，根据 Xcode 提示将工程设置进行更新，点击 Warning 后单击 `Perform Changes` 按钮即可；\n\n![](http://upload-images.jianshu.io/upload_images/1018190-450ad5a3dfe1641f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. 检查设置，将所有 target 的 `Swift 3 @objc Inference` 设置（如果有的话）改为 `Default`，之前改过的话就不用改了；\n3. 搜索 `swift_ver`，可以看到当前的 `Swift Language Version` 已经是 `Swift 4` 了。\n\n![](http://upload-images.jianshu.io/upload_images/1018190-d10ebceafdcfcb6a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n剩下少量方法名变动之类的更新大家可以根据提示自行修改，到这里基本就完成了升级过程，不过先别急，接下来我们看注意事项。\n\n## 二. 注意事项\n\n以下情况必须要给对应的属性或方法添加 `@objc` 标志（当然，他们所在的类肯定也需要添加 `@objc` 标志），不管是通过 OC 还是 Swift 调用：\n\n1. 使用 `@selector()` 或 `#selector()` 方式调用的函数；\n2. 使用 KVC 进行访问的属性；\n3. 使用 IBOutlet 或者 IBAction 和 StoryBoard 绑定的函数或属性。\n\n这些有部分在官方文档中也有提及：\n\n![](http://upload-images.jianshu.io/upload_images/1018190-940d3152de88724d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 三. 一些问题\n\n1. 同一工程的 Pods 库是否可以既有 Swift 3 的也有 Swift 4 的？\n\nSwift 的版本控制粒度在 framework 层面，也就是说同一个工程中不同的 framework 可以是按不同版本的 Swift 进行编译的，所以并不需要等待项目依赖的所有 Pods 库都支持 Swift 4 后再更新，完全可以将已经升级 Swift 4 的库先用起来。\n\n2. `Swift 3 @objc Inference` 选项是干啥的？\n\n在 Swift 4 之前，编译器对 Objective-C 自动提供了一些 Swift 声明。例如，编译器会为 NSObject 子类的所有方法创建 Objective-C 入口点，该机制称为 @objc 推断（@objc Inference）。\n\n在 Swift 4 中，这种自动的 @objc 推断已被废弃，因为生成所有这些 Objective-C 入口点有代价，会增大最终的二进制文件体积。当 `Swift 3 @objc Inference` 设置为 `On` 时，它会按照 Swift 4 之前的模式运行，不进行优化，也就是隐式为我们编写的所有 Swift 代码提供 OC 入口。\n\n但是，当设置为 `On` 时 Xcode 会报一个警告，建议修复这个警告，并将设置切换到 `Default`。新的 Swift 项目的默认为“Default”。可以理解为该项设置为 `On` 时和上文代码转换时选择 `Match Swift 3 Behavior` 选项效果类似。\n\n![](http://upload-images.jianshu.io/upload_images/1018190-f32398e06f3f1538.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 四. 没了\n\n升级完请务必跑一遍整体测试流程，暗坑无数，以防万一，祝大家线上稳定。\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2017/12/05/CocoaPods-Swift4   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["CocoaPods"],"categories":["Swift"]},{"title":"Swift 流水账：踩到一个 Enum 坑（并不是","url":"/2017/08/15/Swift-Enum/","content":"\n今天，天气晴朗，阳光明媚，我像往常一样赖床赖到了九点半，然后在最后一遍起床闹钟的催促声中穿起了衣服，飞一般地冲出了出租屋，蹬上小区门口的小黄，一路冲刺，在即将迟到的前 1s 到达了工位，和平的日常呢。\n\n![](http://upload-images.jianshu.io/upload_images/1018190-ee973c8209f8dd57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n熟练地打开 XCode（我为什么这么熟练呢...）启动项目，开始继续完成产品大大昨天下达的任务。这时，一个枚举进入了我的视野范围内，枚举常量数据类型是 NSUInteger，哼哼，用表驱动法结合 rawValue 的方式，就能优雅地实现这个需求了，完美。\n\n然而，跑了一下居然发生了运行时错误炸掉了...没道理啊，这也能炸...\n\n![EyreFree 眉头一皱，发现事情并不简单](http://upload-images.jianshu.io/upload_images/1018190-59ea929cb1b4246e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点开这个枚举类型，仔细观察了起来...然后发现了一个坑...（应该是我年少无知...\n\n下面，我带着大家一起跳进这个坑...哦不，一起复现一下这个问题：\n\n### 1. 新建一个 OC 的 Pod 库\n\n首先，我们需要新建一个 OC 的 Pod 库，然后在其中定义一个枚举类型，指定枚举值从 2 开始（反正不要是默认的 0 就行），大概这个样子就行了：\n\n```objc\n#import <Foundation/Foundation.h>\n\ntypedef NS_ENUM(NSUInteger, TestEnum) {\n    TestEnumA = 2,\n    TestEnumB,\n    TestEnumC,\n    TestEnumD,\n    TestEnumE,\n};\n\ntypedef TestEnum EFTestEnumType;\n```\n\n![1](http://upload-images.jianshu.io/upload_images/1018190-2529d4f32de43374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 2. 新建一个 Swift 工程\n\n然后，我们再建一个新的 Swift 工程（没错，我司项目是 Swift 的...），在其中引入第一步建好的 CocoaPods 库。到这里，我们可以随便找个地方编写如下测试代码：\n\n```swift\nprint(\"\\(EFTestEnumType.A.rawValue)\")\n```\n先不要执行蛤，大家按住 command 键点击 EFTestEnumType 进入类型定义可以看到如下代码：\n\n```swift\npublic enum TestEnum : UInt {\n    case A\n    case B\n    case C\n    case D\n    case E\n}\npublic typealias EFTestEnumType = TestEnum\n```\n\n注意到了么，这里通过 Pod 库中的原始 OC 代码转化出的中间 Swift 代码的枚举中，并没有指定枚举值的起始值。\n\n![2](http://upload-images.jianshu.io/upload_images/1018190-b2e7873bd027cbed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 3. 编译运行并观察\n\n然后编译运行，观察测试代码的输出会发现，EFTestEnumType.A.rawValue 的值的确是 2...所以，我在主工程中查看了某个枚举类型的定义，而没有注意到 Pod 库中枚举的原始定义是指定了枚举值的起始值的（很好奇为啥这里不一样，搞这么多幺蛾子...），然后就炸了，数组下标越界，初始化失败，随便来一个都会炸掉了...\n\n小伙伴们看懂了么...（嘛，如果这是常识的话...请告诉我我好删掉这篇水文...逃...\n\n![](http://upload-images.jianshu.io/upload_images/1018190-94efe02f989268af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nPS: 文中所用代码可以在 [https://github.com/EyreFree/EFEnumPitDemo](https://github.com/EyreFree/EFEnumPitDemo) 找到。\n\n---\n\n更新：\n\n感谢 [@kemchenj](http://www.weibo.com/kemchenj) 大大的提示，这里应该需要将鼠标悬浮到枚举值之上才可以查看到对应的原始值，反正我还是觉得坑...[摊手]\n\n> @kemchenj：看了很久之后终于懂了，其实主要是 Interface 的锅，Interface 里不会显示枚举值的具体原始值，跟 OC 转 Swift 无关，你可以在 Swift 里定义一个相同的枚举，然后进 Xcode 菜单 -> Navigate -> Jump To Generated Interface，这样就可以看到这个 swift 文件的 Interface 了，也不会具体的 rawValue\n\n![](http://upload-images.jianshu.io/upload_images/1018190-afadd3defe195ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2017/08/15/Swift-Enum   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Enum"],"categories":["Swift"]},{"title":"GitHub Wiki 页面的添加和设置","url":"/2017/07/06/GitHub-Wiki-Introduction/","content":"\n目前大家在 GitHub 上发布的项目，一般使用 Markdown 来编写项目文档和 README.md 等。Markdown 一般情况下能够满足我们的文档编写需求，如果使用得当的话，效果也非常棒。不过当项目文档比较长的时候，阅读体验可能就不是那么理想了，这种情况我想大家应该都曾经遇到过。\n\nGitHub 每一个项目都有一个独立完整的 Wiki 页面，我们可以用它来实现项目信息管理，为项目提供更加完善的文档。我们可以把 Wiki\n 作为项目文档的一个重要组成部分，将冗长、具体的文档整理成 Wiki，将精简的、概述性的内容，放到项目中或是 README.md 里。\n\n## 一. Wiki 简介\n\n> Wiki 是一种在网络上开放且可供多人协同创作的超文本系统，由沃德·坎宁安于 1995 年首先开发，这种超文本系统支持面向社群的协作式写作，同时也包括一组支持这种写作。Wiki 站点可以有多人（甚至任何访问者）维护，每个人都可以发表自己的意见，或者对共同的主题进行扩展或者探讨。\n\n上面这段描述引用自 [百度百科](http://baike.baidu.com/item/wiki/97755)，嗯，实际上百度百科本身也是一个 Wiki，最著名的 Wiki 大概是是 [维基百科](https://zh.wikipedia.org/wiki/%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91) 了吧。\n\n然后 Wiki 页面效果大概可以参考 [Kingfisher](https://github.com/onevcat/Kingfisher/wiki)，看起来还是非常棒的：\n\n![Kingfisher 的 Wiki 页面](http://upload-images.jianshu.io/upload_images/1018190-51b1b1ab89fc7d4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 二. Wiki 的开启和关闭\n\nGitHub 项目的 Wikis 功能默认是开启的，如果你没有找到 Wiki 选项卡，可能是因为该项目关闭了 Wikis 选项，在项目 Setting 中将其选中即可，如图所示：\n\n![Wikis 开关](http://upload-images.jianshu.io/upload_images/1018190-55bf326e65831bdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果在之后某一天决定不再继续使用 Wikis 也可以通过取消该功能的勾选将其关闭，即使已经添加了 Wiki 页面也可以。并且会保存之前的 Wiki 页面内容，即关闭 Wiki 功能并不会清除内容，还可以随时再打开。\n\n## 三. 创建和编辑页面\n\nGitHub 的 Wiki 页面在如图所示选项卡下，默认应该是开启的，但是是空的，我们可以点击中间那个绿色的 `Create the first page` 按钮创建一个页面。\n\n![创建 Wiki 页面](http://upload-images.jianshu.io/upload_images/1018190-fadd06a0b50a299b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果你没有找到 Wiki 选项卡，可能是因为该项目关闭了 Wikis 选项，在项目 Setting 中将其选中即可，参考上文内容。\n\n点击 `Create the first page` 按钮后会进入 Create new page 页面：\n\n![Create new page](http://upload-images.jianshu.io/upload_images/1018190-b5082f398cf04cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n从上往下进行介绍，顶部的输入框是页面标题；Edit mode 控制编辑页面的标记语言类型，这里默认的是 Markdown，支持的类型如下图所示：\n\n![Edit mode 下拉列表](http://upload-images.jianshu.io/upload_images/1018190-8955fdc3169fe36c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n中间的是页面内容，我们可以用 Edit mode 选择的语法在这里编写页面内容；底部编辑框用来输入本次编辑保存时的提交信息；编辑完成后点击 `Save Page` 按钮即可保存，唔，保存前可以先切换到 Preview 选项卡下进行预览，看一下效果是否是自己想要的。\n\n然后保存我们新建的页面，大概会是如下效果：\n\n![新建页面完成](http://upload-images.jianshu.io/upload_images/1018190-f3bbc7ae3f87d86a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击右上角的 `Edit` 按钮可以对当前页面进行编辑，也可以点击 `New Page` 按钮继续添加新的页面。\n\n唔，这里有一点需要注意的是，默认的主页标题必须为 Home，如果不存在标题为 Home 的页面，切换到项目的 Wiki 选项卡时，会显示一个所有页面组成的列表。所以我们的主页必须以 Home 为标题。\n\n![image.png](http://upload-images.jianshu.io/upload_images/1018190-ac17b4a9220d4503.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n目前好像没什么内容，感觉比较空额，不过没关系，接下来我们会一步步完善。\n\n## 四. 添加页脚\n\n点击 Wiki 页面底部的 `Add a custom footer` 按钮，进入新建页脚页面，如图所示：\n\n![Add a custom footer](http://upload-images.jianshu.io/upload_images/1018190-898c1c9b8ff154b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n新建页脚页面实际上就是一个普通的 Create new page 页面，不过标题需要设为 _Footer 并且不能修改（如果修改了就不会被当作页脚来处理了）。\n\n我们可以参考 Kingfisher 的页脚代码，放置多个超链接在这里供读者在阅读完某一页后快速跳转到关键的章节或页面去，具体代码和效果如下：\n\n```markdown\n[Installation](https://github.com/onevcat/Kingfisher/wiki/Installation-Guide) - [Cheat Sheet](https://github.com/onevcat/Kingfisher/wiki/Cheat-Sheet) - [FAQ](https://github.com/onevcat/Kingfisher/wiki/FAQ) - [API Reference](http://onevcat.github.io/Kingfisher/)\n```\n\n![Kingfisher 页脚效果](http://upload-images.jianshu.io/upload_images/1018190-ff95cc5b1f8caeb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当然也可以放一些奇怪的东西，比如，这样的：\n\n![+1s](http://upload-images.jianshu.io/upload_images/1018190-58c20385b24679b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如上图所示，点击页脚右侧的编辑按钮，就可以对页脚进行编辑啦，很方便。\n\n## 五. 添加侧边栏\n\n点击右侧的 `Add a custom sidebar` 按钮可以添加侧边栏，和页脚同理，页面名为特殊的 _Sidebar：\n\n![Add a custom sidebar](http://upload-images.jianshu.io/upload_images/1018190-d71291cb72c041e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们可以参考 Kingfisher 的侧边栏实现，代码和效果如下：\n\n```markdown\n## Getting Started\n\n* [Getting Started with Kingfisher](https://github.com/onevcat/Kingfisher/wiki/Getting-Started-with-Kingfisher)\n    * [Install Kingfisher](https://github.com/onevcat/Kingfisher/wiki/Installation-Guide)\n    * [Cheat Sheet](https://github.com/onevcat/Kingfisher/wiki/Cheat-Sheet)\n* [API Reference](http://onevcat.github.io/Kingfisher/)\n\n## Migration Guide\n\n* [3.0 Migration Guide](https://github.com/onevcat/Kingfisher/wiki/Kingfisher-3.0-Migration-Guide)\n* [2.0 Migration Guide](https://github.com/onevcat/Kingfisher/wiki/Kingfisher-2.0-Migration-Guide)\n\n## Communication\n\n* [FAQ](https://github.com/onevcat/Kingfisher/wiki/FAQ)\n* [Ask a question](http://stackoverflow.com/search?q=kingfisher)\n* [Submit an issue](https://github.com/onevcat/Kingfisher/issues/new)\n* [Open a pull request](https://github.com/onevcat/Kingfisher/compare)\n\n## Information\n\n* [Change Log](https://github.com/onevcat/Kingfisher/blob/master/CHANGELOG.md)\n```\n\n![Kingfisher 的侧边栏](http://upload-images.jianshu.io/upload_images/1018190-eb156bb5531e33ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里的话可以自己适当摸索一下，调整标题层级等样式，以获得一个自己比较满意的展示效果。同样的，点击侧边栏右上角的编辑按钮可以对快速侧边栏进行在线编辑。\n\n![侧边栏编辑按钮](http://upload-images.jianshu.io/upload_images/1018190-9935667a3e9db865.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 六. 查看编辑历史\n\n进入某个页面的编辑页面，点击右上角的 `Page History` 按钮，可以查看该页面的编辑历史，如下图所示：\n\n![Page History 按钮](http://upload-images.jianshu.io/upload_images/1018190-4b8793bbd61f8087.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![编辑历史页面](http://upload-images.jianshu.io/upload_images/1018190-f4738bce2c4201fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 七. 权限控制\n\n那么问题来了，既然是 Wiki 的话，为啥以上这些内容完全是项目所有者一个人手撸呢，完全没有体现出「多人协作」的特性啊喂。\n\n嗯，GitHub Wiki 是可以开放给所有人编辑权限的，不过默认是只有项目所有者和合作者才有权限编辑的，只要到 Setting 中将 Restrict editing to collaborators only 选项去除勾选即可。\n\n![Restrict editing to collaborators only](http://upload-images.jianshu.io/upload_images/1018190-eeda3279fe26cc8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样的话，只要有 GitHub 账号的用户，都可以对该项目的 Wiki 进行编辑。如果怕被胡乱篡改，不想开放编辑权限的话，还是保持勾选好了。\n\n## 八. 本地编辑\n\n唔，上文内容一直在介绍 Wiki 的在线编辑，实际上 Wiki 是一个单独的 Git 仓库，可以 Clone 到本地进行操作\n\n### 1. Wiki 仓库下载\n\n细心的同学应该已经注意到了，Wiki 的右下角处有当前 Wiki 的 Git 仓库地址（我们也可以通过该方法下载他人所属的 Wiki 页面的源代码）：\n\n![Wiki 仓库地址](http://upload-images.jianshu.io/upload_images/1018190-23f30e41d4d6981b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nKingfisher 的 Wiki 仓库结构如下：\n\n![Kingfisher Wiki 结构](http://upload-images.jianshu.io/upload_images/1018190-6795f9e7aaa9440a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来就可以直接对 Wiki 页面源文件进行编辑了，实际上就是一堆 Markdown 文件的组合（或者其他比标记语言，看你选的是啥了）。\n\n### 2. 本地预览\n\n我们在本地手动编辑编辑完成后，只能通过 push 到 GitHub 的方式进行预览，非常不方便，这个时候，就需要借助一个叫 [gollum](https://github.com/gollum/gollum) 的工具了。\n\nGollum 是 GitHub 上用到的 Wiki 引擎，使用它可以在本地上搭建一个类似的GitHub Wiki 的网站，对本地的 Wiki 页面进行快速预览。执行以下命令即可安装：\n\n```\nsudo gem install gollum\n```\n\n安装完成后，将路径切换到 Wiki 的 Git 仓库下然后执行 `gollum` 命令，然后访问 http://127.0.0.1:4567/ 即可进行预览。\n\n![Gollum 预览](http://upload-images.jianshu.io/upload_images/1018190-34b7d6d79ffd94cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 九. 其他\n\nWiki 不仅仅可以作为项目辅助工具来用，你也可以把它当作一个个人信息知识库来使用，不需要搭建，不需要部署，无需付费，方便快捷，更多功鞥大家可以自行开发。\n\n如果你觉得上文的报道，哦不，描述可能有偏差，[GitHub Wiki 的帮助文档](https://help.github.com/categories/wiki/) 也许能给你带来一些帮助。\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2017/07/06/GitHub-Wiki-Introduction   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Wiki"],"categories":["GitHub"]},{"title":"GitHub 项目徽章的添加和设置","url":"/2017/05/01/GitHub-Badge-Introduction/","content":"\n许多同学在 GitHub 上发布了自己的开源项目，有辛苦开发的实用工具、构思巧妙的开源库、别具一格的 App、精心整理的示例代码等等。\n\n自己花了大把时间和精力构建的项目，当然是希望能够得到更多人的关注，被更多的人知晓或者使用。如何更好滴向他人展示自己的项目，介绍项目相关信息呢？用一些通用的小图标来描述项目相关信息不失为一种很棒的选择，几个好看的徽标能够为自己的项目说明增色不少！\n\n# 一. 徽标简介\n\nGitHub 项目的 README.md 中可以添加徽章（Badge）对项目进行标记和说明，这些好看的小图标不仅简洁美观，而且还包含了清晰易读的信息。\n\n徽标主要由图片和对应的链接（当然，你可以不填）组成，徽标图片的话一般由左半部分的名称和右半部分的值组成。\n\n![一枚普通的徽标](http://upload-images.jianshu.io/upload_images/1018190-3489b47031ed2017.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nGitHub 徽标的官方网站是 [http://shields.io/](http://shields.io/)，我萌可以在官网预览绝大部分的徽标样式，然后选择自己喜欢的（当然首先需要适用于自己的目标项目）徽标，添加到自己的项目文档中去。\n\n![Shields.IO](http://upload-images.jianshu.io/upload_images/1018190-b2676f0571e5684c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n下面贴出几个栗子以供参考：\n\n- 正在学习的 ReSwift\n\n[![Build Status](https://img.shields.io/travis/ReSwift/ReSwift/master.svg?style=flat-square)](https://travis-ci.org/ReSwift/ReSwift) [![Code coverage status](https://img.shields.io/codecov/c/github/ReSwift/ReSwift.svg?style=flat-square)](http://codecov.io/github/ReSwift/ReSwift) [![CocoaPods Compatible](https://img.shields.io/cocoapods/v/ReSwift.svg?style=flat-square)](https://cocoapods.org/pods/ReSwift) [![Platform support](https://img.shields.io/badge/platform-ios%20%7C%20osx%20%7C%20tvos%20%7C%20watchos-lightgrey.svg?style=flat-square)](https://github.com/ReSwift/ReSwift/blob/master/LICENSE.md) [![License MIT](https://img.shields.io/badge/license-MIT-blue.svg?style=flat-square)](https://github.com/ReSwift/ReSwift/blob/master/LICENSE.md)\n\n- 大名鼎鼎的 Kingfisher\n\n<p align=\"center\">\n\n<img src=\"https://raw.githubusercontent.com/onevcat/Kingfisher/master/images/logo.png\" alt=\"Kingfisher\" title=\"Kingfisher\" width=\"557\"/>\n\n</p>\n\n<p align=\"center\">\n<a href=\"https://travis-ci.org/onevcat/Kingfisher\"><img src=\"https://img.shields.io/travis/onevcat/Kingfisher/master.svg\"></a>\n<a href=\"https://github.com/Carthage/Carthage/\"><img src=\"https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat\"></a>\n<a href=\"https://swift.org/package-manager/\"><img src=\"https://img.shields.io/badge/SPM-ready-orange.svg\"></a>\n<a href=\"http://onevcat.github.io/Kingfisher/\"><img src=\"https://img.shields.io/cocoapods/v/Kingfisher.svg?style=flat\"></a>\n<a href=\"https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE\"><img src=\"https://img.shields.io/cocoapods/l/Kingfisher.svg?style=flat\"></a>\n<a href=\"http://onevcat.github.io/Kingfisher/\"><img src=\"https://img.shields.io/cocoapods/p/Kingfisher.svg?style=flat\"></a>\n<a href=\"https://codebeat.co/projects/github-com-onevcat-kingfisher\"><img alt=\"codebeat badge\" src=\"https://codebeat.co/assets/svg/badges/A-398b39-669406e9e1b136187b91af587d4092b0160370f271f66a651f444b990c2730e9.svg\" /></a>\n<img src=\"https://img.shields.io/badge/made%20with-%3C3-orange.svg\">\n</p>\n\n- 家喻户晓的 Alamofire\n\n![Alamofire: Elegant Networking in Swift](https://raw.githubusercontent.com/Alamofire/Alamofire/assets/alamofire.png)\n\n[![Build Status](https://travis-ci.org/Alamofire/Alamofire.svg?branch=master)](https://travis-ci.org/Alamofire/Alamofire)\n[![CocoaPods Compatible](https://img.shields.io/cocoapods/v/Alamofire.svg)](https://img.shields.io/cocoapods/v/Alamofire.svg)\n[![Carthage Compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)\n[![Platform](https://img.shields.io/cocoapods/p/Alamofire.svg?style=flat)](http://cocoadocs.org/docsets/Alamofire)\n[![Twitter](https://img.shields.io/badge/twitter-@AlamofireSF-blue.svg?style=flat)](http://twitter.com/AlamofireSF)\n[![Gitter](https://badges.gitter.im/Alamofire/Alamofire.svg)](https://gitter.im/Alamofire/Alamofire?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\n\n徽标并不是添加的越多越好，合理地选择适合项目的徽标做具有针对性地添加才是理性的做法，像 [EFQRCode](https://github.com/EyreFree/EFQRCode) 这样堆积徽标的无脑行为并不是十分可取，在这里提出这一点，希望大家不要盲目追求数量。\n\n- 腊鸡 EFQRCode\n\n![](https://raw.githubusercontent.com/EyreFree/EFQRCode/assets/EFQRCode.jpg)\n\n<p align=\"center\">\n<a href=\"https://travis-ci.org/EyreFree/EFQRCode\"><img src=\"http://img.shields.io/travis/EyreFree/EFQRCode.svg\"></a>\n<a href=\"https://codecov.io/gh/EyreFree/EFQRCode\"><img src=\"https://codecov.io/gh/EyreFree/EFQRCode/branch/master/graph/badge.svg\"></a>\n<a href=\"https://github.com/Carthage/Carthage/\"><img src=\"https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat\"></a>\n<a href=\"https://swift.org/package-manager/\"><img src=\"https://img.shields.io/badge/SPM-ready-orange.svg\"></a>\n<a href=\"http://cocoapods.org/pods/EFQRCode\"><img src=\"https://img.shields.io/cocoapods/v/EFQRCode.svg?style=flat\"></a>\n<a href=\"http://cocoapods.org/pods/EFQRCode\"><img src=\"https://img.shields.io/cocoapods/p/EFQRCode.svg?style=flat\"></a>\n<a href=\"https://github.com/apple/swift\"><img src=\"https://img.shields.io/badge/language-swift-orange.svg\"></a>\n<a href=\"https://codebeat.co/projects/github-com-eyrefree-efqrcode-master\"><img src=\"https://codebeat.co/badges/01f53e9d-542c-4c22-adc7-d1dbff0d2a6f\"></a>\n<a href=\"https://raw.githubusercontent.com/EyreFree/EFQRCode/master/LICENSE\"><img src=\"https://img.shields.io/cocoapods/l/EFQRCode.svg?style=flat\"></a>\n<a href=\"https://gitter.im/EFQRCode/Lobby\"><img src=\"https://badges.gitter.im/EyreFree/EFQRCode.svg\"></a>\n<a href=\"https://twitter.com/EyreFree777\"><img src=\"https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?style=flat\"></a>\n<a href=\"http://weibo.com/eyrefree777\"><img src=\"https://img.shields.io/badge/weibo-@EyreFree-red.svg?style=flat\"></a>\n</p>\n\n当然如果个人比较喜欢的话，请随意添加。\n\n![请随意](http://upload-images.jianshu.io/upload_images/1018190-bd12202658a6a391.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 二. 常用徽标添加\n\n常用的徽标主要有持续集成状态、项目版本信息、代码测试覆盖率、项目支持平台、项目语言、代码分析等，下面我萌就来依次添加这些可爱的徽标！\n\n## 1. 持续集成状态\n\n持续集成的话推荐 [Travis CI](https://travis-ci.org/)，针对开源项目免费，所以你的私有项目无法享受到免费的持续构建服务，不过我们的目的貌似就是给开源项目添加徽标。\n\n同类型的产品还有 [CircleCI](https://circleci.com)，不过目前跑 OS X 项目需要额外付费，免费版提供一个 Linux 项目队列，作为非付费用户在这里不多做评价，大佬们可以自己试下。其他还有诸如 [Jenkins](https://jenkins.io/)\n 和 [Codeship](https://codeship.com/) 等，大家可以在 [http://shields.io/](http://shields.io/) 的 `Build` 这一栏自行翻阅。\n\n接下来就是 Travis CI 的集成工作了，首先打开 [https://travis-ci.org/](https://travis-ci.org/) 注册一个 Travis-CI 账号，可以通过 GitHub 账户直接登陆。\n\n然后参考 [官方文档](https://docs.travis-ci.com/user/getting-started/)，根据你的项目语言或类型选择具体的配置方式，主要就是在项目中添加一个 `.travis.yml` 配置文件，告诉 Travis CI 怎样对你的项目进行编译或测试。这里有一个 Swift CocoaPods 库的集成示例，可以参考一下：[http://www.jianshu.com/p/beaa9ec9183d](http://www.jianshu.com/p/beaa9ec9183d)。\n\n然后徽标图片地址是这个样子的：\n\n```\nhttp://img.shields.io/travis/{GitHub 用户名}/{项目名称}.svg\n```\n\n将上面 URL 中的 {GitHub 用户名} 和 {项目名称} 替换为你的即可，再加上该项目在 Travis CI 上的地址，以 Alamofire 为例，最后集成完成的 Markdown 代码和效果大概是这个样子：\n\n```markdown\n[![](https://travis-ci.org/Alamofire/Alamofire.svg?branch=master)](https://travis-ci.org/Alamofire/Alamofire)\n```\n[![](https://travis-ci.org/Alamofire/Alamofire.svg?branch=master)](https://travis-ci.org/Alamofire/Alamofire)\n\n当然如果你的编译没跑过或者发生错误之类的，会出现其他的状态，比如酱紫的：\n\n![](https://img.shields.io/codeship/d6c1ddd0-16a3-0132-5f85-2e35c05e22b1.svg)\n\n![](https://img.shields.io/vso/build/larsbrinkhoff/953a34b9-5966-4923-a48a-c41874cfb5f5/1.svg)\n\n![](https://img.shields.io/snap-ci/ThoughtWorksStudios/eb_deployer/master.svg)\n\n这里需要指出的是，开源项目的 Travis CI 也是公开的，包括日志和历史记录在内，都是针对所有人可见的，所以小伙伴们一定不要把密码、私钥等重要信息暴露了。\n\n## 2. 项目下载量\n\n项目被下载的次数，这个的话各个平台的统计都是独立的，比如发布在 CocoaPods 的项目下载量徽标图片地址如下，以 AFNetworking 为例：\n\n```\n总下载量：https://img.shields.io/cocoapods/dt/AFNetworking.svg\n月下载量：https://img.shields.io/cocoapods/dm/AFNetworking.svg\n周下载量：https://img.shields.io/cocoapods/dw/AFNetworking.svg\n```\n\n效果如下：\n\n![](https://img.shields.io/cocoapods/dt/AFNetworking.svg)\n![](https://img.shields.io/cocoapods/dm/AFNetworking.svg)\n![](https://img.shields.io/cocoapods/dw/AFNetworking.svg)\n\n如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 AFNetworking 改为自己的项目名称即可。更多其他发布方式如 apm、npm、Gem 等可查阅 [http://shields.io/](http://shields.io/) 的 `Downloads` 一栏。\n\n## 3. 项目版本信息\n\n这个的话，因为我的 iOS 库是发布在 CocoaPods 的，我用的是 CocoaPods 提供的，URL 如下：\n\n```\nhttps://img.shields.io/cocoapods/v/{项目名称}.svg?style=flat\n```\n\n以 Alamofire 为例，Markdown 代码和效果如下：\n\n```markdown\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat)\n```\n\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat)\n\n如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 Alamofire 改为自己的项目名称即可。更多其他发布方式如 apm、npm、Gem 等可查阅 [http://shields.io/](http://shields.io/) 的 `Version` 一栏，这里提供一个可以查询已发布的各种包的版本号徽标地址的网站 [https://badge.fury.io/](https://badge.fury.io/)，可以轻松获取对应包的徽标代码，如下图所示\n\n![](http://upload-images.jianshu.io/upload_images/1018190-a6257e9b997c4a7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果你的发布工具不提供项目版本信息的徽标的话，可以用自定义徽标的方式实现，具体可参考下文自定义徽标一节，这里给出徽标代码：\n\n```\nhttps://img.shields.io/badge/{发布方式}-{版本号}-519dd9.svg\n```\n\n将 {发布方式} 和 {版本号} 替换为你的项目目前的发布方式和版本号即可，例如通过 360 应用商店发布，发布版本号为 v1.2.3：\n\n```\n![](https://img.shields.io/badge/360_store-v1.2.3-519dd9.svg)\n```\n\n![](https://img.shields.io/badge/360_store-v1.2.3-519dd9.svg)\n\n## 4. 代码测试覆盖率\n\n代码测试覆盖率的话推荐 [Codecov](https://codecov.io/)。同类产品有 [Coveralls](https://coveralls.io/)，不过网站风格略复古，文档也不详细，安装过程也复杂，需要配置一大堆奇怪的东西，遂不推荐。\n\n同样的，Codecov 可以直接使用 GitHub 账号登陆，需要结合 Travis CI 使用，在 `.travis.yml` 文件中添加一个回调触发 Codecov 的刷新，同时需要打开工程中的测试覆盖信息收集，XCode 中的设置如下\n\n![Paste_Image.png](http://upload-images.jianshu.io/upload_images/1018190-a1fceb0028ce645a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n更多信息可参考 [官方文档](https://docs.codecov.io/docs) 和 [示例](https://github.com/codecov)。\n\n然后，我们就可以在 Setting 中的 Badge 一栏找到添加图标的代码啦：\n\n![Paste_Image.png](http://upload-images.jianshu.io/upload_images/1018190-95306d0d263235c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n最终效果如下：\n\n[![codecov](https://codecov.io/gh/EyreFree/EFQRCode/branch/master/graph/badge.svg)](https://codecov.io/gh/EyreFree/EFQRCode)\n\n## 5. 项目支持平台\n\n这个的话，因为我的 iOS 库是发布在 CocoaPods 的，我用的是 CocoaPods 提供的，URL 如下：\n\n```\nhttps://img.shields.io/cocoapods/p/{项目名称}.svg?style=flat\n```\n\n以 Alamofire 为例，Markdown 代码和效果如下：\n\n```markdown\n![](https://img.shields.io/cocoapods/p/Alamofire.svg?style=flat)\n```\n\n![](https://img.shields.io/cocoapods/p/Alamofire.svg?style=flat)\n\n如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 Alamofire 改为自己的项目名称即可。如果你的发布工具不提供项目支持平台的徽标的话，可以用自定义徽标的方式实现，具体可参考下文自定义徽标一节，这里给出徽标代码：\n\n```\nhttps://img.shields.io/badge/platform-{项目支持平台}-lightgrey.svg\n```\n\n将 {项目支持平台} 替换为你的项目目前的版本号即可，例如 ios：\n\n```\n![](https://img.shields.io/badge/platform-ios-lightgrey.svg)\n```\n\n![](https://img.shields.io/badge/platform-ios-lightgrey.svg)\n\n## 6. 项目语言\n\n嗯，这个完全是用自定义徽标实现的，具体可参考下文自定义徽标一节，这里给出徽标代码：\n\n```\nhttps://img.shields.io/badge/language-{项目语言}-{背景色}.svg\n```\n\n将 {项目语言} 和 {背景色} 替换为你的项目目前的语言和你想要的背景色即可，这里以 Swift 为例，我们用上 Swift 官方橘色：\n\n```\n![](https://img.shields.io/badge/language-swift-orange.svg)\n```\n\n![](https://img.shields.io/badge/language-swift-orange.svg)\n\n完美!\n\n![Swift](http://upload-images.jianshu.io/upload_images/1018190-7aaab9c7de41a78c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 7. 代码分析\n\n> [Codebeat](https://codebeat.co/) 可以计算全局项目评分、GPA、和不同命名空间的等级来帮助您量化技术债务和发现重构机会，你唯一需要做的就是连接你的 Github 库，获得反馈就好了。\n\n嗯，上面是官方自述，大概意思就是每次 push 或者 merge 之后会对代码进行分，给出评分，然后告诉你哪些地方复杂度过高需要进行重构之类的。用 GitHub 登陆后绑定项目即可，无需对原有项目进行修改（其实是 codebeat 在你的项目设置里加了一个 Webhook，通知它重新计算评分）。\n\n![Webhooks](http://upload-images.jianshu.io/upload_images/1018190-271c429613a8d34e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n照着引导巴拉巴拉一顿操作之后就可以获取图标啦，在项目的 Setting 中可以获取徽标代码，自己复制出来就可以。\n\n![Setting](http://upload-images.jianshu.io/upload_images/1018190-080b0705f241d072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n最终效果如下：\n\n[![codebeat badge](https://codebeat.co/badges/01f53e9d-542c-4c22-adc7-d1dbff0d2a6f)](https://codebeat.co/projects/github-com-eyrefree-efqrcode-master)\n\n## 8. 开源协议类型\n\n这个的话，因为我的 iOS 库是发布在 CocoaPods 的，我用的是 CocoaPods 提供的，URL 如下：\n\n```\nhttps://img.shields.io/cocoapods/l/{项目名称}.svg?style=flat\n```\n\n以 Alamofire 为例，Markdown 代码和效果如下：\n\n```markdown\n![](https://img.shields.io/cocoapods/l/Alamofire.svg?style=flat)\n```\n\n![](https://img.shields.io/cocoapods/l/Alamofire.svg?style=flat)\n\n如果你的库已经发布到 CocoaPods 的话，我们只要把上面的 Alamofire 改为自己的项目名称即可。如果你的发布工具不提供开源协议类型的徽标的话，可以用自定义徽标的方式实现，具体可参考下文自定义徽标一节，这里给出徽标代码：\n\n```\nhttps://img.shields.io/badge/license-{协议名称}-000000.svg\n```\n\n将 {协议名称} 替换为你的项目所使用的协议名称即可，例如 MIT：\n\n```\n![](https://img.shields.io/badge/license-MIT-000000.svg)\n```\n\n![](https://img.shields.io/badge/license-MIT-000000.svg)\n\n# 三. 自定义徽标\n\n## 1. 标题／内容／颜色／链接\n\n如果以上这些徽标没有满足你的需求，我们还可以定制自己的个性化徽标，`shields.io` 提供了添加自定义徽标的功能，通过修改如下 URL 即可获取自定义徽标图片：\n\n```\nhttps://img.shields.io/badge/{徽标标题}-{徽标内容}-{徽标颜色}.svg\n```\n\n{徽标标题}：徽标左半部分的文本（短线：--，下划线：\\_\\_，空格： 或\\_）；   \n{徽标内容}：徽标右半部分的文本，同上；   \n{徽标颜色}：徽标右半部分背景颜色，可以是 red、green、blue 等颜色英文单词，也可以直接写十六进制的颜色值，如 ff69b4，示例如下：\n\n![](https://img.shields.io/badge/color-brightgreen-brightgreen.svg?maxAge=2592000)\n![](https://img.shields.io/badge/color-green-green.svg?maxAge=2592000)\n![](https://img.shields.io/badge/color-yellowgreen-yellowgreen.svg?maxAge=2592000)\n![](https://img.shields.io/badge/color-yellow-yellow.svg?maxAge=2592000)\n![](https://img.shields.io/badge/color-orange-orange.svg?maxAge=2592000)\n![](https://img.shields.io/badge/color-red-red.svg?maxAge=2592000)\n![](https://img.shields.io/badge/color-lightgrey-lightgrey.svg?maxAge=2592000)\n![](https://img.shields.io/badge/color-blue-blue.svg?maxAge=2592000)\n![](https://img.shields.io/badge/color-ff69b4-ff69b4.svg?maxAge=2592000)\n\n将其中的 {徽标标题}、{徽标内容}、{徽标颜色} 分别替换为需要的内容即可，例如我的微博徽标图片地址如下：\n\n```\nhttps://img.shields.io/badge/weibo-@EyreFree-red.svg\n```\n\n再结合我的微博地址 [http://weibo.com/eyrefree777](http://weibo.com/eyrefree777) 后完整徽标代码和效果如下（如果这段代码用在 GitHub 的话，点击该徽标会打开对应的 URL 地址，即直接跳到我的微博）：\n\n```markdown\n[![](https://img.shields.io/badge/weibo-@EyreFree-red.svg)](http://weibo.com/eyrefree777)\n```\n\n[![](https://img.shields.io/badge/weibo-@EyreFree-red.svg)](http://weibo.com/eyrefree777)\n\n同理我的推特徽标代码和效果如下：\n\n```markdown\n[![](https://img.shields.io/badge/twitter-@EyreFree777-blue.svg)](https://twitter.com/EyreFree777)\n```\n\n[![](https://img.shields.io/badge/twitter-@EyreFree777-blue.svg)](https://twitter.com/EyreFree777)\n\n## 2. 附加参数\n\n可以在徽标图片 URL 后面带上一些参数来控制徽标的样式，这一部分是可选的，不想折腾的话默认的样式就挺好了，可以不看这里的。\n\n使用方法就是在徽标图片 URL 后面跟上 `?{参数名}={参数值}`\n\n多个参数联用的话就是 `?{参数名1}={参数值1}&{参数名2}={参数值2}...`\n\n### 1. style\n\nstyle 控制徽标的主体样式，有四种，不设置的话默认是 `flat` 的，示例代码和效果如下：\n\n#### plastic\n\n塑料？大概是指立体效果\n\n```markdown\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=plastic)\n```\n\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=plastic)\n\n#### flat\n\n正常的样子，扁平化\n\n```markdown\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat)\n```\n\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat)\n\n#### flat-square\n\n扁平化 + 去除圆角\n\n```markdown\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat-square)\n```\n\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=flat-square)\n\n#### social\n\n社交样式\n\n```markdown\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=social)\n```\n\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?style=social)\n\n### 2. label\n\n该参数可以用来强制覆盖原有的徽标标题文字，效果如下，原有的 pod 字样已经被覆盖了：\n\n```markdown\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?label=healthinesses)\n```\n\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?label=healthinesses)\n\n\n### 3. logo\n\n该参数可以用来为徽标添加 logo，logo 图片会出现在左半部分的徽标标题左边，logo 图片高度必须 ≥ 14px，logo 图片需要先转为 base64 编码然后直接插入到 URL 中（可以用 [http://b64.io/](http://b64.io/) 将图片转为 base64 编码的字符串），格式如下。\n\n```\n?logo={base64 编码后的图片数据}\n```\n\n示例代码和效果如下：\n\n```\n![](https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT%2FnZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B%2FWFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D%2FcTK%2FQ6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm%2Fhid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH%2FuoPnu%2FBfZ7Zxb0AAAAASUVORK5CYII)\n```\n\n![](https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT%2FnZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B%2FWFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D%2FcTK%2FQ6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm%2Fhid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH%2FuoPnu%2FBfZ7Zxb0AAAAASUVORK5CYII)\n\n### 4. logoWidth\n\n该参数可以设置在上一个参数 logo 中添加的图标的宽度，设为 0 的话即为忽略该参数，示例代码和效果如下：\n\n```\n![](https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logoWidth=100&logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT%2FnZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B%2FWFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D%2FcTK%2FQ6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm%2Fhid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH%2FuoPnu%2FBfZ7Zxb0AAAAASUVORK5CYII)\n```\n\n![](https://img.shields.io/badge/gadget-Raspberry%20Pi-pink.svg?logoWidth=100&logo=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAACJ0lEQVR4AW2Qy0tUfxjGv3Pm3O%2BXGec3jnMZZ9Rxxp%2BWkYpJ2QkVIzDpkkoGBSOpBZmWgRIkWSs30SJchC26B9aijKLaFET9Be1q46ayRVDU5uk9Q8seeOG8X573eT%2FnZbwQqo5l5Rube52PQdH3BcaY4SbEiy2%2B%2FWFLv7ueblJv0luJmRHBHzqfwuyDRkzfKqB8pRZeQnwzuZynvgHTtwsYvZRBs2%2BVGSU5nfsjX2bocexqDsMLKXgZCQfmkzi6lK0EDJxOfNJdoYORQl5O3OeXY5%2BH59PI5XXUMh3RuIQR6v2J2Ld8h3488FXMBWb2TJkNPw9GUzirF3HX2oZFrQUD0Rqc84rfVcaPs0D%2FcTK%2FQ6y6N6eVsJX3MCglcUzJYVytw6CYxKRSj1Elu0bWCBNCXCnPGz96pTieOTvxyN6OIm%2Fhid2Nx1SzWhGxsLwR4aQ9rFOMPl8lwwQlvXZ78NLZhRbBwZrTjReOjzuENKc1YUTOrLJ%2BKf7%2BsrEJhIL7dhfOaI34n7cxpRWwYnbghFqPMmENyelXzOLE0d1SNbrFGOKcgmDwnduH61Y7zJCAvVINDisZJMPqNEuHVeOQnPr11u3FESWLa2ZbBecp8VNaZXBBb15njHUxmxPC7YK3uGS0YkzNo1VwcZJWtwkeThHKMg33SfEVMqsskBeSjLqwMZYKa18ppXKRwESIv0u8NVPFyRb7hxK0ZYX%2BfIPO95D6KBXH%2FuoPnu%2FBfZ7Zxb0AAAAASUVORK5CYII)\n\n### 5. link\n\n据说该参数是用来设置 style 为 social 类型点击后跳转的 URL 的（嗯，俗称超链接），并且应该能够设置左右两边为不同的 URL，官方描述如下：\n\n- Specify what clicking on the left/right of a badge should do (esp. for social badge style)\n\n如果把 URL 贴到浏览器中直接访问的确是这样的，比如直接在浏览器中打开下面这个链接，点击左半部分会跳到百度，右半部分则跳到 Google（感谢 [@yuzhouwww](https://github.com/yuzhouwww) 同学的提示）：\n\n[https://img.shields.io/badge/weibo-@EyreFree-red.svg?style=social&link=https://www.baidu.com&link=https://www.google.com](https://img.shields.io/badge/weibo-@EyreFree-red.svg?style=social&link=https://www.baidu.com&link=https://www.google.com)\n\n不过如果直接添加在 Markdown 中显示貌似没啥效果？如果有大佬知道的求指点，感谢！\n\n```\n![](https://img.shields.io/badge/weibo-@EyreFree-red.svg?style=social&link=https://www.baidu.com&link=https://www.google.com)\n```\n\n![](https://img.shields.io/badge/weibo-@EyreFree-red.svg?style=social&link=https://www.baidu.com&link=https://www.google.com)\n\n### 6. colorA\n\n该参数用来控制徽标左半部分的背景色，只能用十六进制的颜色作为参数哦，不能直接写 red、green、blue 之类的，这里将左半部分的背景色改为 0xabcdef，代码和效果如下：\n\n```markdown\n![](https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorA=abcdef)\n```\n\n![](https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorA=abcdef)\n\n### 7. colorB\n\n该参数用来控制徽标右半部分的背景色，同上，只能用十六进制的颜色作为参数哦，不能直接写 red、green、blue 之类的，这里将右半部分的背景色改为 0xabcdef，代码和效果如下：\n\n```markdown\n![](https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorB=abcdef)\n```\n\n![](https://img.shields.io/badge/twitter-@EyreFree777-blue.svg?colorB=abcdef)\n\n### 8. maxAge\n\n该参数用来设置 HTTP 缓存时间，以秒为单位，直接在 svg 地址后跟 `?maxAge={缓存秒数}` 即可，好像没啥好预览的，不放效果图了。\n\n### 备注\n\n这里需要注意的是，如果你是引用的第三方 svg 然后添加自己的样式，如果该样式之前已经被第三方添加过，是不一定会覆盖第三方的设置的，也就是说自己设置的属性不一定会生效...例如下面的代码设置 colorB 就没生效：\n\n```markdown\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?colorB=000000)\n```\n\n右半部分应该变成黑色，但是毫无效果的说：\n\n![](https://img.shields.io/cocoapods/v/Alamofire.svg?colorB=000000)\n\n# 四. 其他\n\n默认的徽标是居左排列的，如果需要居中排列需要使用 HTML 的方式来插入徽标，可参考 [Kingfisher](https://github.com/onevcat/Kingfisher)，代码和效果如下：\n\n```html\n<p align=\"center\">\n<a href=\"https://travis-ci.org/onevcat/Kingfisher\"><img src=\"https://img.shields.io/travis/onevcat/Kingfisher/master.svg\"></a>\n<a href=\"https://github.com/Carthage/Carthage/\"><img src=\"https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat\"></a>\n<a href=\"https://swift.org/package-manager/\"><img src=\"https://img.shields.io/badge/SPM-ready-orange.svg\"></a>\n<a href=\"http://onevcat.github.io/Kingfisher/\"><img src=\"https://img.shields.io/cocoapods/v/Kingfisher.svg?style=flat\"></a>\n<a href=\"https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE\"><img src=\"https://img.shields.io/cocoapods/l/Kingfisher.svg?style=flat\"></a>\n<a href=\"http://onevcat.github.io/Kingfisher/\"><img src=\"https://img.shields.io/cocoapods/p/Kingfisher.svg?style=flat\"></a>\n<a href=\"https://codebeat.co/projects/github-com-onevcat-kingfisher\"><img alt=\"codebeat badge\" src=\"https://codebeat.co/assets/svg/badges/A-398b39-669406e9e1b136187b91af587d4092b0160370f271f66a651f444b990c2730e9.svg\" /></a>\n</p>\n```\n\n<p align=\"center\">\n<a href=\"https://travis-ci.org/onevcat/Kingfisher\"><img src=\"https://img.shields.io/travis/onevcat/Kingfisher/master.svg\"></a>\n<a href=\"https://github.com/Carthage/Carthage/\"><img src=\"https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat\"></a>\n<a href=\"https://swift.org/package-manager/\"><img src=\"https://img.shields.io/badge/SPM-ready-orange.svg\"></a>\n<a href=\"http://onevcat.github.io/Kingfisher/\"><img src=\"https://img.shields.io/cocoapods/v/Kingfisher.svg?style=flat\"></a>\n<a href=\"https://raw.githubusercontent.com/onevcat/Kingfisher/master/LICENSE\"><img src=\"https://img.shields.io/cocoapods/l/Kingfisher.svg?style=flat\"></a>\n<a href=\"http://onevcat.github.io/Kingfisher/\"><img src=\"https://img.shields.io/cocoapods/p/Kingfisher.svg?style=flat\"></a>\n<a href=\"https://codebeat.co/projects/github-com-onevcat-kingfisher\"><img alt=\"codebeat badge\" src=\"https://codebeat.co/assets/svg/badges/A-398b39-669406e9e1b136187b91af587d4092b0160370f271f66a651f444b990c2730e9.svg\" /></a>\n</p>\n\n没了，🙄\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2017/05/01/GitHub-Badge-Introduction   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Badge"],"categories":["GitHub"]},{"title":"iOS 在 App 中使用自定义字体","url":"/2017/03/23/UIFont-TTF/","content":"\n最近在做一个神奇的 App 需要添加楷体，检查了一下发现 iOS 默认并不会安装这种字体，需要我们自己将字体文件添加到 App 中，本文主要记录了添加自定义字体的过程、添加完成后的效果以及遇到的一些坑，文中 iOS 代码主要为 Swift 3。\n\n---\n\n# 1. 查看全部可用字体\n\n在进行操作之前，我们先查看默认情况下，系统的可用字体有哪些，利用如下代码可以将系统全部字体的 FontFamilyName 以及它们的 FontName 进行打印：\n\n```swift\nfor fontFamily in UIFont.familyNames {\n    print(fontFamily)\n\n    for font in UIFont.fontNames(forFamilyName: fontFamily) {\n        print(fontFamily + \": \" + font)\n    }\n}\n```\n\n我们可以在日志输出窗口搜索我们需要的楷体，可以看到默认并没有安装，效果如图所示：\n\n![查看全部可用字体](http://upload-images.jianshu.io/upload_images/1018190-7350c33cc8513393.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 2. 获取字体文件\n\n首先，我们需要获取字体文件，一般文件类型为 ttf 或 ttc 的就是字体文件了，如图所示：\n\n![字体文件](http://upload-images.jianshu.io/upload_images/1018190-8128dda0b2489f39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以在 [字体口袋](http://www.zitikoudai.com/)，[搜字网](http://www.sozi.cn/) 之类的网站找到很多可供下载的资源：\n\n![字体口袋](http://upload-images.jianshu.io/upload_images/1018190-510dc0d1628c7b4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n或者也可以在 OS X 的系统字体册找到我们想要的字体，可以从应用程序列表中打开字体册：\n\n![字体册](http://upload-images.jianshu.io/upload_images/1018190-ec156aacb9194153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n选择 `所有字体` 然后在搜索栏内键入需要查找的字体名即可列出匹配的项目：\n\n![在字体册中查找字体](http://upload-images.jianshu.io/upload_images/1018190-29901f9b4632925f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n右键点击想要的字体选择 `在 Finder 中显示` 即可找到对应的字体文件。\n\n# 3. 添加字体文件到工程\n\n将我们获取的字体文件直接拖到工程中的合适位置，如图所示：\n\n![添加字体文件](http://upload-images.jianshu.io/upload_images/1018190-2aad3e8abae38ee9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n添加完成后选中对应的字体文件可进行预览：\n\n![预览](http://upload-images.jianshu.io/upload_images/1018190-5f5b457a8bdda98b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们还需要在 `Info.plist` 文件中添加 Fonts provided by application 项，如图所示：\n\n![Info.plist 添加 Fonts provided by application 项](http://upload-images.jianshu.io/upload_images/1018190-be03386c8a892c1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n也可通过直接添加代码的方式完成，例如这里添加两个字体文件 STKaiti.ttf 和 Kaiti-SC.ttf 的代码如下：\n\n```\n<key>UIAppFonts</key>\n<array>\n    <string>STKaiti.ttf</string>\n    <string>Kaiti-SC.ttf</string>\n</array>\n```\n\n这时，我们对工程进行编译，再次查看可用的全部字体，这时我们可以看到，我们需要的楷体已经添加了进来：\n\n![成功添加楷体](http://upload-images.jianshu.io/upload_images/1018190-35090eacafa8f523.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 4. 字体的使用\n\n## 1. StoryBoard\n\n在 StoryBoard 中使用的话，只需要设置控件的 Font 属性为，选择 Custom，然后再从 Family 中选择需要的字体即可。\n\n![在 StoryBoard 中使用](http://upload-images.jianshu.io/upload_images/1018190-ae1d2f52ed178db2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2. 代码\n\n我们直接通过如下代码直接生成一个楷体的字体对象，将其赋给 UIButton 或者 UILabel 等空间对应的属性即可。\n\n```swift\nUIFont(name: \"STKaiti\", size: 20)\n```\n\n这里需要注意的是 UIFont 的 name 字符串必须是上面我们打印出的字体名称，和字体文件的文件名或者其他信息无关。如果这里我们输入了一个无效的字体名称，可能会返回一个空的对象，所以我的使用方式如下：\n\n```swift\nimport Foundation\n\nextension UIFont {\n\n    static func boldKaiti(ofSize fontSize: CGFloat) -> UIFont {\n        return UIFont(name: \"Kaiti SC Black\", size: fontSize) ?? UIFont.systemFont(ofSize: fontSize)\n    }\n\n    static func kaiti(ofSize fontSize: CGFloat) -> UIFont {\n        return UIFont(name: \"Kaiti SC\", size: fontSize) ?? UIFont.systemFont(ofSize: fontSize)\n    }\n}\n```\n\n使用楷体前后效果对比，可以看到换个字体以后感觉整个 feel 就不一样了，可见我们要好好听设计师蜀黍们的话，该用啥字体用啥字体，不能偷懒，😂 （嘛，控件位置还没调整，第二段可能有点放不下了）：\n\n添加字体前|添加字体后\n:-------------------------:|:-------------------------:\n![](http://upload-images.jianshu.io/upload_images/1018190-af181721cca8c174.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)|![](http://upload-images.jianshu.io/upload_images/1018190-e089745639153fd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 5. 一些坑\n\n#### 1. 字体文件过大\n\n如果你用的字体文件是 TTC 格式的，可以考虑去下载单独的 TTF 字体文件，TTC 是几个 TTF 合成的字库，里面包含不止一种字体类型。\n\n然后多个类似的字体，可以和设计师商量一下统一使用同一种字体。\n\n唔，如果是单个 TTF 文件过大的话，暂时木有找到好的解决办法，可以考虑多下几个不同来源的同种字体的文件，挑一个体积最小的。或者对现有的 TTF 文件进行编辑，将一些低频字符进行删除。\n\n#### 2. 字体重名问题\n\n在导入同一种字体的不同风格时，比如这里楷体的粗体 `Kaiti-SC-Black` 和普通体 `Kaiti-SC-Regular` ，在 App 中打印出的 FontName 居然只有一个楷体的，这是为啥呢，推测可能是字体文件生成的时候填写字体名偷工减料，没有填写完整的字体名或者字体名识别异常导致的。\n\n![只有一个楷体](http://upload-images.jianshu.io/upload_images/1018190-cd76f9fd80856fbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后我找了一个 OS X 下可用的免费字体编辑工具 BirdFont 对字体文件进行查看想一探究竟，官网地址 [https://birdfont.org/](https://birdfont.org/)，我用的是 [2.15.5](http://eyrefree.coding.me/FileKeeper/birdfont-2.15.5-free.dmg) 版本，大家可以自行去官网下载最新版。\n\n在 Finder 中打开我们的字体文件，右键选择用 BirdFont 进行打开即可，因为字体文件数据量较大，打开过程可能会有些长，需要耐心等待几分钟，具体时长根据数据量而定，等软件右上角的 Loading 消失即表示打开完成。\n\n点击右上角菜单，选择 Name and Description 选项可打开字体描述信息编辑页面：\n\n![Name and Description](http://upload-images.jianshu.io/upload_images/1018190-f0a8629b4d2b6382.png)\n\n在这里我们可以看到，Kaiti-SC-Black 和 Kaiti-SC-Regular 两个字体文件的 `Name` 一栏确实是只写了 Kaiti SC，和我们之前在 App 中输出的字体名称一致，`Style` 一栏虽然有所区别，但是我们在 App 中是无法通过 `Style` 这个参数来找到某个字体的（反正我没找到，如果真的有办法希望可以教我，蟹蟹，😂 ），所以这应该就是我们只能在 App 中找到一个楷体的原因了。\n\nBirdFont Kaiti-SC-Black|BirdFont Kaiti-SC-Regular|App\n:-------------------------:|:-------------------------:|:-------------------------:\n![](http://upload-images.jianshu.io/upload_images/1018190-36d14efc746d886a.png)|![](http://upload-images.jianshu.io/upload_images/1018190-c828d1f366a82258.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)|![](http://upload-images.jianshu.io/upload_images/1018190-4b11a9f1122e702b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后我们对其中一个字体的 `Name` 做一下修改，反正使俩字体文件的 Name 不一样就行，然后我这里将 Kaiti-SC-Black 的 `Name` 改为 Kaiti SC Black，改完之后需要先 Save，然后选择 Import and Export：\n\n![Import and Export](http://upload-images.jianshu.io/upload_images/1018190-c27be693b5abdae5.png)\n\n然后再选择 Export Fonts：\n\n![Export Fonts](http://upload-images.jianshu.io/upload_images/1018190-0d4f161f80baa28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后会弹出 Export Settings 页面进行一些参数设置，注意将 Formats 中的 TTF 选项勾选即可，其他的两个选项可以去掉，加快导出速度。\n\n![Export Settings](http://upload-images.jianshu.io/upload_images/1018190-2a2a4271cfbc9133.png)\n\n然后单击下面的 Export 按钮即可开始导出工作，右上角会出现一个 Loading 视图，等它消失就表示导出完成了，导出完成后会在 Finder 中打开对应字体文件。\n\n![导出完成](http://upload-images.jianshu.io/upload_images/1018190-06962a1c5acf94a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们将其添加到工程中再看下能不能找到它：\n\n![新增 Kaiti SC Black 字体](http://upload-images.jianshu.io/upload_images/1018190-96d28c83f011ed0c.png)\n\n可以看到这一次多了一个名为 Kaiti SC Black 的字体，完成！\n\nPS：\n\n最后吐槽一下，BirdFont 这工具真的好慢，巨慢，慢到爆炸，🙄 。大家在操作过过程中尽量挑体积小一点的字体文件进行操作。不过还好，使用过程中还没遇到闪退之类的状况，功能上没问题。希望后续版本能够提高处理速度。\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2017/03/23/UIFont-TTF   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["TTF"],"categories":["iOS"]},{"title":"利用 Travis-CI 让你在 GitHub 上的 CocoaPods 库持续构建","url":"/2017/03/16/Travis-CI/","content":"\nTravis-CI 是一个专门为开源项目打造的持续集成环境，目前已经支持绝大部分主流语言，它采用 yaml 格式，简洁清新独树一帜（感谢百度百科，2333）。\n\n每次 Commit 后会执行构建操作，并在 GitHub 对应的 Commit 后显示构建状态或结果，如图所示：\n\n![持续构建效果预览](http://upload-images.jianshu.io/upload_images/1018190-87b43c1d2d1e9c1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n本文以 [EFQRCode](https://github.com/EyreFree/EFQRCode)(一个使用 Swift 作为开发语言的 CocoaPods 开源库) 为例，简述怎样为自己的开源项目添加持续构建功能。\n\n# 1. 指定 Swift 版本\n\n在根目录下添加一个 .swift-version 文件，在其中填写 Swift 版本号，例如这里 EFQRCode 库使用 Swift 3.0 进行开发，所以这里填写的是：\n\n```\n3.0\n```\n\n# 2. 添加 Travis-CI 配置文件\n\n在根目录下添加一个 .travis.yml 文件，在其中填写配置信息：\n\n```\nosx_image: xcode8\nlanguage: objective-c\n\ncache: cocoapods\npodfile: Example/Podfile\n\nenv:\n  global:\n    - LANG=en_US.UTF-8\n    - LC_ALL=en_US.UTF-8\n    - XCODE_WORKSPACE=Example/EFQRCode.xcworkspace\n  matrix:\n    - SCHEME=\"EFQRCode-Example\"\n\nbefore_install:\n  - gem install xcpretty --no-rdoc --no-ri --no-document --quiet\n  - gem install cocoapods --pre --no-rdoc --no-ri --no-document --quiet\n  - pod install --project-directory=Example\n\nscript:\n  - set -o pipefail\n  - xcodebuild -workspace \"$XCODE_WORKSPACE\" -scheme \"$SCHEME\" -configuration Debug clean build CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO | xcpretty -c\n  - xcodebuild -workspace \"$XCODE_WORKSPACE\" -scheme \"$SCHEME\" -configuration Release clean build CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO | xcpretty -c\n  - pod lib lint --no-clean\n\nafter_success:\n  - sleep 5\n```\n\n# 3. 注册 Travis-CI 账号\n\n打开 [https://travis-ci.org/](https://travis-ci.org/) 注册一个 Travis-CI 账号，也可以通过 GitHub 账户直接登陆。Travis-CI 服务对开源项目是免费的，所以你的私有项目无法享受到免费的持续构建服务。\n\n# 4. 从 GitHub 同步项目\n\n第一次进入时会自动从 GitHub 同步项目数据，可能需要等待一段的时间进行同步，同步完成后可以看到如下的项目列表：\n\n![项目列表](http://upload-images.jianshu.io/upload_images/1018190-d01facdae4cb29f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n一般情况下每隔一定的时间 Travis-CI 都会从 GitHub 自动同步数据，如果新添加的项目想要立刻同步到 Travis-CI 的话，可以手动点击右上角的 Sync account 同步按钮，如图所示：\n\n![同步按钮](http://upload-images.jianshu.io/upload_images/1018190-d14d4450f3790330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 5. 开启持续集成\n\n然后接下来就是开启对应项目的持续构建，大家应该已经猜到该怎么做了吧...将对应项目之前的 Switch 按钮设为启用绿色勾选状态即可，如图所示：\n\n![勾选状态](http://upload-images.jianshu.io/upload_images/1018190-2085dfac1d55e776.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 6. 观察错误日志\n\n若发生构建失败，可通过查看错误日志的方式来定位具体问题原因，可点击工程名，选择出错的那一次构建即可：\n\n![构建日志](http://upload-images.jianshu.io/upload_images/1018190-a483be7d32c674bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 7. 一些废话\n\n本文只提供了针对 Swift CocoaPods 库的操作步骤，Travis-CI 具体到每种语言／项目的构建配置各不相同，参数各异，有的时候还需要根据自己的项目特性做一些个性化的调整，需要我们多思考，多调试，多尝试，总之不要轻易放弃哇。别问我是怎么知道的，😂 ：\n\n![坑](http://upload-images.jianshu.io/upload_images/1018190-7cbf867d9314dbbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2017/03/16/Travis-CI   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Travis-CI"],"categories":["GitHub"]},{"title":"iOS 利用 NEHotspotHelper 获取 WiFi 列表","url":"/2017/03/09/NEHotspotHelper/","content":"\niOS 9 发布之后，苹果推出了 NetworkExtension，利用这个框架可以实现很多和网络相关的操作。本文主要介绍怎样使用其中的 NEHotspotHelper 进行设备 WiFi 列表的获取。\n\nDemo 地址：[https://github.com/EyreFree/EFNEHotspotHelperDemo](https://github.com/EyreFree/EFNEHotspotHelperDemo)\n\n# 一. 注意事项\n\n1. 首先，NEHotspotHelper 只在 iOS 9 及以上版本得到支持，之前版本的 iOS 并不支持该功能；\n2. 然后，你需要有一个开发者账号；\n3. 最后，该框架目前还没有大规模开放使用，所以需要向苹果发送申请并且审核通过才能够获得使用该框架的权限，大致内容就是描述一下你需要使用该框架的原因之类的，然后我是用的英文进行描述（感谢百度以及谷歌翻译），不过据说中文也行。提交申请后大概一周内会收到反馈邮件，申请地址为： [https://developer.apple.com/contact/network-extension/](https://developer.apple.com/contact/network-extension/) 。\n\n# 二. 创建 App ID\n\n打开苹果开发者中心，登陆然后找到 App IDs 选项，点击右上角按钮创建一个 App ID 用于接下来创建 Provisioning Profile，地址为： [https://developer.apple.com/account/ios/identifier/bundle/](https://developer.apple.com/account/ios/identifier/bundle/)  ，如图所示：\n\n![创建 App ID](http://upload-images.jianshu.io/upload_images/1018190-f447bfbbb6095d33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n首先，填写 Name 以及 Bundle ID，这里统一填写为 EFNEHotspotHelperDemo，如图所示：\n\n![填写 Name](http://upload-images.jianshu.io/upload_images/1018190-1fda13b55d6683a6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![填写 Bundle ID](http://upload-images.jianshu.io/upload_images/1018190-a51c01c1bb8e0ef9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来这一步注意需要勾选 Wireless Accessory Configuration 这一选项，如图所示：\n\n![勾选 Wireless Accessory Configuration](http://upload-images.jianshu.io/upload_images/1018190-5acb269c05aacea5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后观察到如图所示状态表明已成功打开：\n\n![状态显示](http://upload-images.jianshu.io/upload_images/1018190-73d2e00e40181d9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在 App IDs 列表中查看刚创建完成的 App ID：\n\n![App IDs 列表](http://upload-images.jianshu.io/upload_images/1018190-2d0024f561ed17ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 三. 创建 Provisioning Profile\n\n找到 Provisioning Profiles 选项，点击右上角按钮创建一个 Provisioning Profile 用于接下来创建示例工程，地址为： [https://developer.apple.com/account/ios/profile/](https://developer.apple.com/account/ios/profile/)  ，如图所示：\n\n![创建 Provisioning Profile](http://upload-images.jianshu.io/upload_images/1018190-911e7761ba3c44e3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n首先选择 Profile 类型，这里我选择的是 iOS App Development，可以根据自己的具体需要自由选择：\n\n![选择 Profile 类型](http://upload-images.jianshu.io/upload_images/1018190-d5061ad530a3f724.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来选择我们在第二步创建好的 App ID，如图所示：\n\n![选择 App ID](http://upload-images.jianshu.io/upload_images/1018190-4e017ec4c1c09402.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后选择证书和设备，全选即可：\n\n![选择证书](http://upload-images.jianshu.io/upload_images/1018190-9c675e9238d1da11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![选择设备](http://upload-images.jianshu.io/upload_images/1018190-58a130484fdfed6c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在额外权限这一步需要选中我们申请到的 Network Extension 权限，可以看到其中包含我们需要使用的 NEHotspotHelper 权限，如图所示：\n\n![选中 Network Extension 权限](http://upload-images.jianshu.io/upload_images/1018190-a6abfce07b76a017.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n填写完 Profile Name 之后，即可成功创建我们需要的 Profile：\n\n![填写 Profile Name](http://upload-images.jianshu.io/upload_images/1018190-2f602ebf05102c28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击 Download 将它下载到本地：\n \n![下载 Profile](http://upload-images.jianshu.io/upload_images/1018190-1bf8b38560227b93.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n双击打开，即可将 Profile 添加到本机：\n\n![添加 Profile](http://upload-images.jianshu.io/upload_images/1018190-42e294701187033a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以到 XCode 的账户设置里查看已安装的 Profile，若未安装成功可以尝试点击 Action 中的 Download 按钮重新下载：\n\n![查看已安装的 Profile](http://upload-images.jianshu.io/upload_images/1018190-99fff3c8f41706d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 四. 创建工程\n\n接下来我们创建一个示例工程，演示如何获取 WiFi 列表。首先，将 Bundle ID 改为之前设置的 EFNEHotspotHelperDemo：\n\n![修改 Bundle ID](http://upload-images.jianshu.io/upload_images/1018190-a39aced31600687a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后在 Info.plist 中添加后台模式权限数组：\n\n![添加后台模式代码](http://upload-images.jianshu.io/upload_images/1018190-1870d94c708379d7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n代码如下：\n\n```html\n<key>UIBackgroundModes</key>\n<array>\n\t<string>network-authentication</string>\n</array>\n```\n\n添加完成后可以在 Target -> Capabilities 中看到后台模式已处于开启状态：\n\n![后台模式已开启](http://upload-images.jianshu.io/upload_images/1018190-99c24463ac8fa56f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来在 Capabilities 找到 Wireless Accessory Configuration 并将其打开：\n\n![打开 Wireless Accessory Configuration](http://upload-images.jianshu.io/upload_images/1018190-8eb012d9732a3197.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n 在工程中找到后缀为 {工程名}.entitlements 的文件 EFNEHotspotHelperDemo.entitlements，在其中加入 HotspotHelper 权限代码：\n\n![添加 HotspotHelper 权限代码](http://upload-images.jianshu.io/upload_images/1018190-065ba9d93185a539.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n代码如下：\n\n```xml\n<key>com.apple.developer.networking.HotspotHelper</key>\n<true/>\n```\n\n好了，到这里已经完成了各种乱七八糟的配置工作，可以尝试进行 Build。如果没有提示错误信息的话，接下来就可以愉快地使用 HotspotHelper 了；如果有问题的话，请检查之前的步骤是否都已正确完成或者根据错误信息修改具体项目。\n\n# 五. 核心代码\n\n首先，在需要使用 HotspotHelper 的地方添加头文件引用，这里以 Objective-C 代码为例：\n\n```\n#import <NetworkExtension/NetworkExtension.h>\n```\n\n然后使用如下代码即可将 WiFi 列表信息打印到 XCode 控制台，注意：这里需要打开系统 `设置` 中的 `无线局域网` 页面才可以触发回调：\n\n```\n- (void)scanWifiInfos{\n    NSLog(@\"1.Start\");\n\n    NSMutableDictionary* options = [[NSMutableDictionary alloc] init];\n    [options setObject:@\"EFNEHotspotHelperDemo\" forKey: kNEHotspotHelperOptionDisplayName];\n    dispatch_queue_t queue = dispatch_queue_create(\"EFNEHotspotHelperDemo\", NULL);\n\n    NSLog(@\"2.Try\");\n    BOOL returnType = [NEHotspotHelper registerWithOptions: options queue: queue handler: ^(NEHotspotHelperCommand * cmd) {\n\n        NSLog(@\"4.Finish\");\n        NEHotspotNetwork* network;\n        if (cmd.commandType == kNEHotspotHelperCommandTypeEvaluate || cmd.commandType == kNEHotspotHelperCommandTypeFilterScanList) {\n            // 遍历 WiFi 列表，打印基本信息\n            for (network in cmd.networkList) {\n                NSString* wifiInfoString = [[NSString alloc] initWithFormat: @\"---------------------------\\nSSID: %@\\nMac地址: %@\\n信号强度: %f\\nCommandType:%ld\\n---------------------------\\n\\n\", network.SSID, network.BSSID, network.signalStrength, (long)cmd.commandType];\n                NSLog(@\"%@\", wifiInfoString);\n\n                // 检测到指定 WiFi 可设定密码直接连接\n                if ([network.SSID isEqualToString: @\"测试 WiFi\"]) {\n                    [network setConfidence: kNEHotspotHelperConfidenceHigh];\n                    [network setPassword: @\"123456789\"];\n                    NEHotspotHelperResponse *response = [cmd createResponse: kNEHotspotHelperResultSuccess];\n                    NSLog(@\"Response CMD: %@\", response);\n                    [response setNetworkList: @[network]];\n                    [response setNetwork: network];\n                    [response deliver];\n                }\n            }\n        }\n    }];\n\n    // 注册成功 returnType 会返回一个 Yes 值，否则 No\n    NSLog(@\"3.Result: %@\", returnType == YES ? @\"Yes\" : @\"No\");\n}\n```\n\n# 六. 演示\n\n唔，Demo 运行效果如下，点击 `Open WiFi Setting` 按钮可直接打开 `无线局域网` 页面：\n\n![运行效果](http://upload-images.jianshu.io/upload_images/1018190-761d24d00368fc0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n具体可尝试下载 Demo 并完成相应配置后体验：[https://github.com/EyreFree/EFNEHotspotHelperDemo](https://github.com/EyreFree/EFNEHotspotHelperDemo)\n\n# 七. 备注\n\n参考以下资料完成本 Demo，在此表示感谢：\n\n[IOS NetworkExtension 框架使用笔记](http://blog.csdn.net/i374711088/article/details/51655526)\n[iOS NEHotspotHelper使用](http://blog.csdn.net/toto18369905359/article/details/52622115)\n[iOS-NetworkExtension-NEHotspotHelper](https://github.com/42vio/iOS-NetworkExtension-NEHotspotHelper)\n[API Reference - NetworkExtension](https://developer.apple.com/reference/networkextension)\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2017/03/09/NEHotspotHelper   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["NEHotspotHelper"],"categories":["iOS"]},{"title":"十分钟开发一款 iOS 表情包 App","url":"/2016/11/24/Coding-Emoji/","content":"\n在最近更新的 iOS 10 系统中，苹果开放了 iMessage Stickers 的开发，通俗的说法就是我们现在可以为 iMessage 开发表情包了。\n表情包的开发十分简单，不需要写一行代码，只需要准备好图片资源即可。本文主要以 Coding 的[洋葱猴系列表情](https://coding.net/u/coding/p/Onion-Monkey-Emoji/git)为例快速开发一款表情包 App。\n\n本文所需所有素材以及工程文件地址：  \n[https://github.com/EyreFree/CodingEmoji](https://github.com/EyreFree/CodingEmoji)\n\n---\n# 一.注意事项\n开发环境：XCode 8.0 及以上；\n运行环境：iOS 10 及以上；\n其他：表情包图片的格式可以是 JPG, PNG, GIF 等，不过单张图片最大不能超过 500KB。\n\n# 二.准备图片\n下载洋葱猴表情包，找到其中的表情图片。\n（下载地址：https://coding.net/u/coding/p/Onion-Monkey-Emoji/git）\n\n![洋葱猴表情包](http://upload-images.jianshu.io/upload_images/1018190-5bcefc958791bbeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 三.建立工程\n## 1.新建工程\n打开 XCode，新建 Sticker Pack Application 工程，如图所示：\n\n![新建 Sticker Pack Application 工程](http://upload-images.jianshu.io/upload_images/1018190-0b7408065e8b9efa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2.添加图标\nSticker Pack Application 的图标和一般的 iOS 应用不太一样，它部分图标是扁的，详细尺寸如下（最后一个为 App Store 需要上传的图标尺寸。其他为工程内用到的应用图标）：\n\n| No | Size | PS |\n|:---:|:-------------:|:-----:|\n| 1 | 54 x 40 ||\n| 2 | 58 x 58 ||\n| 3 | 64 x 48 ||\n| 4 | 81 x 60 ||\n| 5 | 87 x 87 ||\n| 6 | 96 x 72 ||\n| 7 | 120 x 90 ||\n| 8 | 134 x 100 ||\n| 9 | 148 x 110 ||\n| 10 | 180 x 135 ||\n| 11 | 1024 x 768 ||\n| 12 | 1024 x 1024 | App Store 应用图标 |\n\n![应用图标](http://upload-images.jianshu.io/upload_images/1018190-7a4a2618c8a958f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 3.导入表情图片\n接下来，可以将我们想要添加到表情包里的图片拖到 Sticker Pack 目录中，如图所示：\n\n![导入表情图片](http://upload-images.jianshu.io/upload_images/1018190-dde7f28f09c1cf87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 4.修改表情包名称\n我们可以通过修改 Display Name 的方式来修改表情包在设备上显示的名称：\n\n![修改表情包名称](http://upload-images.jianshu.io/upload_images/1018190-9bcbb6f8e0315fcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 四.测试\n完成上面这些步骤后，就可以编译然后进行测试了，模拟器中运行效果如图所示：\n\n![最终运行效果](http://upload-images.jianshu.io/upload_images/1018190-248481f796531dbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 五.提交审核\n（这一步不算在 10 分钟里哦，不属于开发过程唉，顺带提一下凑字数，🙄，购买开发者账号要等好几天呢）\n若已经准备好了 iOS 开发者账号，就可以直接提交审核了，嗯，这个时候需要准备两张运行效果的屏幕截图，分别是 iPhone 和 iPad 的。\n\n| Device | Size |\n|:---:|:-------------:|\n| iPhone | 1242 x 2208 |\n| iPad | 2048 x 2732 |\n\n然后应用图标使用之前准备好的 1024 x 1024 的应用图标即可，接下来填写好应用的各种信息，然后存储-提交审核即可。\n\n本文 App 已经通过审核，iOS 10 以上系统的同学可以下载体验：\n[https://itunes.apple.com/cn/app/yang-cong-hou-biao-qing-bao/id1166254758?mt=8](https://itunes.apple.com/cn/app/yang-cong-hou-biao-qing-bao/id1166254758?mt=8)\n\n同时预祝各位同学顺利开发出属于自己的表情包应用。\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2016/11/24/Coding-Emoji   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Sticker"],"categories":["iOS"]},{"title":"iOS 为 App 添加 3D Touch 快捷菜单","url":"/2016/09/22/3D-Touch/","content":"\niOS 为 App 图标添加 3D Touch 快捷启动菜单，Demo 地址：[https://github.com/EyreFree/EF3DTouchDemo](https://github.com/EyreFree/EF3DTouchDemo)\n\n---\n\n# 1.注意事项\n\n3D Touch 只在 iOS 9 及以上版本得到支持，之前版本的 iOS 并不支持该功能；\n3D Touch 只在 iPhone 6s 及以后型号的 iPhone 或 iPad Pro 上可用，更早的设备并不支持该功能。\n具体可通过如下代码进行判断：\n\n```\nif self.traitCollection.forceTouchCapability == UIForceTouchCapability.available {\n    print(\"支持 3D Touch\")\n} else {\n    print(\"不支持 3D Touch\")\n}\n```\n\n# 2.添加按钮\n\n右键点击工程中的 Info.plist 文件选择打开方式为 Source Code：\n\n<center>\n![以 Source Code 方式打开 Info.plist](/images/3D-Touch-1.png)\n</center>\n\n在其中填写如下代码：\n\n```\n<key>UIApplicationShortcutItems</key>\n<array>\n    <dict>\n        <key>UIApplicationShortcutItemIconType</key>\n        <string>UIApplicationShortcutIconTypeShuffle</string>\n        <key>UIApplicationShortcutItemTitle</key>\n        <string>3D Touch 测试按钮</string>\n        <key>UIApplicationShortcutItemType</key>\n        <string>0</string>\n    </dict>\n    <dict>\n        <key>UIApplicationShortcutItemIconType</key>\n        <string>UIApplicationShortcutIconTypeLove</string>\n        <key>UIApplicationShortcutItemTitle</key>\n        <string>出来吧，小火龙！</string>\n        <key>UIApplicationShortcutItemType</key>\n        <string>1</string>\n    </dict>\n</array>\n```\n\n其中 UIApplicationShortcutItemIconType 项代表按钮图标，更多图标可以参见： [https://developer.xamarin.com/api/type/UIKit.UIApplicationShortcutIconType/](https://developer.xamarin.com/api/type/UIKit.UIApplicationShortcutIconType/)\n\n<center>\n![在 Info.plist 添加按钮代码](/images/3D-Touch-2.png)\n</center>\n\n这段代码添加了两个 3D Touch 按钮，“3D Touch 测试按钮”和“3D 出来吧，小火龙！”。\n\n<center>\n![成功添加 3D Touch 按钮](/images/3D-Touch-3.png)\n</center>\n\n# 3.添加功能代码\n\n打开 AppDelegate.swift 在其中添加如下代码，这段代码对点击按钮操作进行了处理，点击按钮后会进入 App 弹出一个显示按钮名称的对话框：\n\n```\nfunc application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) {\n\n    var sourceButtonTitle: String?\n\n    //根据按钮标题进行进一步操作\n    switch shortcutItem.localizedTitle {\n    case \"3D Touch 测试按钮\":\n        sourceButtonTitle = \"来源按钮：3D Touch 测试按钮\"\n        break\n    case \"出来吧，小火龙！\":\n        sourceButtonTitle = \"来源按钮：出来吧，小火龙！\"\n        break\n    default:\n        break\n    }\n\n    //测试操作：弹出一个对话框显示来源按钮\n    if let trySourceButtonTitle = sourceButtonTitle {\n        let alert = UIAlertController(title: nil, message: trySourceButtonTitle, preferredStyle: .alert)\n        alert.addAction(UIAlertAction(title: \"知道啦\", style: .cancel, handler: nil))\n        self.window?.rootViewController?.present(alert, animated: true, completion: nil)\n    }\n}\n```\n\n<center>\n![在 AppDelegate.swift 添加功能代码](/images/3D-Touch-4.png)\n</center>\n\n我们可以在这里添加代码从而实现根据不同来源按钮而执行不同的操作，结果如图所示：\n\n<center>\n![操作结果](/images/3D-Touch-5.png)\n</center>\n\n# 4.其他\n\n1.需要注意的是，快捷启动按钮最多只能添加 4 个。\n2.最新的 iOS 10 系统会给所有的 App 额外添加一个 3D Touch 分享按钮，点击后不打开 App 而是调用系统分享该应用的 App Store 下载地址。\n\n---\n\n参考资料：\n\n[http://iostuts.io/2015/10/08/how-to-add-quick-actions/](http://iostuts.io/2015/10/08/how-to-add-quick-actions/)\n[http://stackoverflow.com/questions/36369058/how-to-check-3d-touch-available-in-iphone-programatically](http://stackoverflow.com/questions/36369058/how-to-check-3d-touch-available-in-iphone-programatically)\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2016/09/22/3D-Touch   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["3D Touch"],"categories":["iOS"]},{"title":"OS X 下统计项目代码行数","url":"/2016/07/19/Wrap-Count/","content":"\n这是一条普通的计算代码行数的命令，在终端中切换到源码文件所在目录下执行即可：\n\n```\nfind . \"(\" -name \"*.m\" -or -name \"*.mm\" -or -name \"*.swift\" -or -name \"*.cpp\" -or -name \"*.h\" -or -name \"*.rss\" \")\" -print | xargs wc -l\n\n```\n\n可以计算代码行数，源码文件类型在命令里哦，可以根据自己需要修改，上面这条是计算 iOS 项目的，效果如下：\n\n![Wrap-Count-1.png](/images/Wrap-Count-1.png)\n\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2016/07/19/Wrap-Count   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Nothing"],"categories":["OS X"]},{"title":"iOS 获取当前 WiFi 信息","url":"/2016/03/30/iOS-WiFi-Info/","content":"\n此处以 Swift 代码为例\n\n---\n# 1.添加模块引用\n首先我们在需要获取 WiFi 信息的地方引用需要的模块：\n```swift\nimport SystemConfiguration.CaptiveNetwork\n```\n\n# 2.添加获取代码\n接下来编写获取 WiFi 信息的代码，如下：\n```swift\n//获取 WiFi 信息\nfunc getWifiInfo() -> (ssid: String, mac: String) {\n    if let cfas: NSArray = CNCopySupportedInterfaces() {\n        for cfa in cfas {\n            if let dict = CFBridgingRetain(\n                CNCopyCurrentNetworkInfo(cfa as! CFString)\n                ) {\n                if let ssid = dict[\"SSID\"] as? String,\n                    let bssid = dict[\"BSSID\"] as? String {\n                    return (ssid, bssid)\n                }\n            }\n        }\n    }\n    return (\"未知\", \"未知\")\n}\n```\n\n# 3.获取 WiFi 信息\n然后在我们需要获取 WiFi 信息的位置添加如下代码即可：\n```swift\nlet wifiInfo = getWifiInfo()\nNSLog(\"SSID(WiFi名称): \\(wifiInfo.0)\")\nNSLog(\"BSSID(Mac地址): \\(wifiInfo.1)\")\n```\n\n# 4.输出结果\n\n<center>\n![iOS-WiFi-Info-1](/images/iOS-WiFi-Info-1.png)\n</center>\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2016/03/30/iOS-WiFi-Info   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Nothing"],"categories":["iOS"]},{"title":"OS X 下使用 Hexo 和 Coding Pages 搭建静态博客","url":"/2016/03/23/Hexo-Coding-Pages/","content":"\n[Hexo](https://github.com/hexojs/hexo) 是一款基于 Node.js 的静态博客框架, 目前在 GitHub 上已有 9133 star 和 1499 fork。Hexo 生成的静态页面可以部署在 Github 或 Coding 上，并且能够免费绑定自己的域名，可以用来很方便地搭建个人博客。\n\n---\n# 1，Git 安装  \n搭建博客需要用到 git，下面这条命令可查看本机是否已安装 git，若未安装可参考[这篇博文](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000/)进行安装。\n```bash\ngit --version\n```\n\n# 2，安装 Node.js\nMac下最简单的做法便是直接下载pkg文件进行安装，最新版本的下载地址如下，选择后缀为pkg的文件下载安装即可：  \n[https://nodejs.org/download/release/latest/](https://nodejs.org/download/release/latest/)  \n完装完成后，要将以下路径计入你的系统环境变量 /usr/local/bin，步骤如下：\n用vim 打开该文件：\n```bash\ncd; vi .bash_profile\n```\n在文件中加入该语句：\n```bash\nexport PATH=/usr/local/bin:$PATH\n```\n并保存退出，重新加载shell让设置的环境变量生效：\n```bash\nsource ~/.bash_profile\n```\n\n# 3，将 npm 的源替换成淘宝的源\n由于众所周知的原因，国内访问官方默认 npmjs.org 源速度不是十分理想，所以建议切换成国内的，利用以下命令将其替换为淘宝的 npm 源： \n```bash\nnpm config set registry http://registry.npm.taobao.org/\n```\n\n# 4，安装 Hexo\n利用 npm 命令安装：\n```bash\nsudo npm install -g hexo\n```\n因为可能有文件读写权限的问题，这里推荐用 sudo，输入密码后会开始安装，时间可能比较长，耐心等待，如果长时间卡在某一步 Ctrl + C 终止当前任务后重试即可。\n\n# 5，本地建立博客  \n安装完成后，新建一个目录如 myblog 用于存放博客，切换到该目录下执行以下指令，Hexo 即会在目标文件夹初步生成博客所需要的所有文件：\n```bash\nhexo init\n```\n然后切换到该目录下执行如下命令，安装所需要的依赖：\n```bash\nsudo npm install\n```\n网上有大量开发者们分享的模板可供选择使用，将它们的 Git 仓库 Clone 以后放到博客目录下的 themes 文件夹中即可：  \n[Github Hexo Themes](https://github.com/hexojs/hexo/wiki/Themes)  \n[有哪些好看的 Hexo 主题？](http://www.zhihu.com/question/24422335)  \n本博客的搭建我选择了使用该主题：  \nhttps://github.com/forsigner/fexo  \n在这里对原作者 forsigner 表示感谢，🙏\n\n# 6，安装 Server 组件\n保持在本地博客路径下，在终端中执行如下命令：\n```bash\nhexo\n```\n因为这并不是一个完整的命令，所以这时我们可以看到 hexo 输出的帮助信息，如下图所示：\n\n<center>\n![Hexo-Coding-Pages-1](/images/Hexo-Coding-Pages-1.png)\n</center>\n\n我们可以在左边的 Commands 列表中查看我们需要的命令是否已成功安装，因为某些版本的 Hexo 的 Server 模块需要独立安装所以这里我们并没有看到 server 命令，我们可以执行下面这条命令来进行安装，如果有的话可以跳过这一步：\n```bash\nsudo npm install hexo-server --save\n```\n如果安装过程中出现一些问题导致某些模块没有安装成功的也可以通过类似的方式单独安装某个模块进行修复。\n\n# 7，安装 RSS 插件（可忽略）  \n到博客所在目录 myblog 下，利用该命令安装 RSS 插件，暂时不需添加 RSS 功能的同学可忽略该步骤：\n```bash\nsudo npm install hexo-generator-feed --save\n```\n编辑 myblog 目录下的 _config.yml，添加如下代码开启 RSS 功能：  \n```bash\nrss: /atom.xml\n```\nRSS 地址保持默认即可，不需要多做修改。\n\n# 8，本地效果预览  \n在终端使用 cd 命令切换到博客所在目录 myblog，执行如下命令生成静态博客页面并启动本地服务器，若成功可在浏览器中访问 http://localhost:4000/ 进行预览。 \n```bash\nhexo generate\nhexo server\n```\n或者如下的缩写形式也可以：\n```bash\nhexo g\nhexo s\n```\n\n# 9，部署到 Coding Pages  \n在 Coding 新建一个项目，假设为 myblog，然后修改本地博客目录下的 _config.yml 文件，根据[官方文档](https://hexo.io/docs/deployment.html)的描述，修改以下几个参数，这些参数一般在文件底部：\n```bash\ndeploy:\ntype: git               #部署方式，这里我们用的是Coding的Git\nrepo: <repository url>  #仓库地址，例如我的是git@git.coding.net:eyrefree/myblog.git   \nbranch: [branch]        #分支名，可任意填写，我填写的是master\nmessage: [message]      #可不填，这是显示在提交记录里的描述信息，默认为日期\n```\n参数修改完成后，我们需要在终端中切换到博客所在目录安装 deploy 组建，执行以下命令将生成的博客静态页面 push 到我们上面在 Coding 创建的 myblog 仓库中：\n```bash\nsudo npm install hexo-deployer-git --save\n```\n然后执行依次执行清理命令：\n```bash\nhexo clean\n```\n生成命令：\n```bash\nhexo g\n```\n部署命令：\n```bash\nhexo d\n```\n如果在 _config.yml 的 repo 处填写的仓库地址是 https 形式的，在部署时可能需要输入你的 Coding 账号和密码。  \n然后切换到该项目的 Pages 标签，开启 pages 服务，分支名填写为我们在_config.yml 文件中设定的分支，我的是 master。\n\n# 10，服务器效果预览  \npages 服务开启完成后，Coding 会提供一个类似 {user_name}.coding.me/{project_name} 的链接用于访问，例如用户名为 eyrefree 项目名为 myblog 的链接应该是： \n```bash\nhttp://eyrefree.coding.me/myblog\n```\n访问该链接即可进行预览，由于我们引用的资源很多是和域名相关的，导致这里可能会有资源加载失败的情况，只能出现部分文字，接下来我们将域名绑定后即可恢复正常。\n\n# 11，绑定域名  \n默认提供的链接可能过长或者不便于日常使用，我们也可以绑定自己的域名。  \n首先，需要提前准备一个域名，然后打开自己的域名控制面板，新建一个 CNAME 解析到 {user_name}.coding.me，例如我的是将 www.eyrefree.org 解析到 eyrefree.coding.me；  \n然后，打开 Coding 项目页面切换到 pages 项，填入刚才的设置解析的域名 www.eyrefree.org，点击“添加域名绑定”按钮即可，在浏览器中直接访问 www.eyrefree.org 就能成功打开。  \n有时可能由于缓存或者解析时间的问题，稍等片刻即可。 \n\n# 12，编写博文  \n接下来就是日常的博文编写啦，这里是使用 markdown 格式的，编写完成后添加到 source/_posts 目录下然后按照第 8 步的方法部署到 Coding 服务器即可，具体可参考[这篇博文](http://www.jianshu.com/p/3c7ddd48bfa9)，Markdown 的一些语法可以参考：  \n[http://wowubuntu.com/markdown/](http://wowubuntu.com/markdown/)\n\n# 13，常见问题\n若执行 hexo 命令时出现如下警告信息：\n```bash\n{ [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n{ [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n{ [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' }\n```\n可以尝试执行以下命令修复：\n```bash\nsudo npm install hexo --no-optional\n```\n\n---\n嘛，大概就是这些内容了，有遗漏的话会继续补充，😝。[我的博客](http://www.eyrefree.org)是用 Hexo 生成的使用了 Fexo 模版，开启了 Google 统计，Disqus 评论，RSS 订阅，站内搜索等，详情参见我的 Coding 仓库的 Hexo 分支：\n[https://coding.net/u/eyrefree/p/blog.eyrefree.org/git](https://coding.net/u/eyrefree/p/blog.eyrefree.org/git)\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2016/03/23/Hexo-Coding-Pages   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Hexo"],"categories":["Blog"]},{"title":"iOS 在 App 中获取 XCode 构建信息","url":"/2016/03/08/iOS-Build-Info/","content":"\niOS 在 App 中获取当前版本的构建时间和 Git Hash 值，Demo 地址：  \n[https://github.com/EyreFree/EFBuildInfoDemo](https://github.com/EyreFree/EFBuildInfoDemo)\n\n---\n# 1.添加 Run Script\n打开需要获取构建信息的工程，选中工程，切换到 Build Phases 选项卡，点击左边的“+”号选择“New Run Script Phase”一项添加一个新的 Run Script：\n\n<center>\n![iOS-Build-Info-1](/images/iOS-Build-Info-1.png)\n</center>\n\n并将其命名为“Build Config\"，然后将其拖动到“Target Dependencies”的下面：\n\n<center>\n![iOS-Build-Info-2](/images/iOS-Build-Info-2.png)\n</center>\n\n# 2.为 Run Script 添加代码\n点开“Build Config\"左边的小三角，在其中填写如下代码：\n```bash\nmyFile=\"BuildConfig.plist\"\n\nmyDate=`date +%Y-%m-%dT%H:%M:%S%z`\necho $myDate\nmyHash=`git rev-parse --short HEAD`\necho $myHash\n\nif [ ! -f \"$myFile\" ]; then\n    /usr/libexec/PlistBuddy -c \"Add :BUILD_TIME string $myDate\" \"$myFile\"\n    /usr/libexec/PlistBuddy -c \"Add :GIT_SHA string $myHash\" \"$myFile\"\nelse\n    /usr/libexec/PlistBuddy -c \"Set :BUILD_TIME $myDate\" \"$myFile\"\n    /usr/libexec/PlistBuddy -c \"Set :GIT_SHA $myHash\" \"$myFile\"\nfi\n```\n\n<center>\n![iOS-Build-Info-3](/images/iOS-Build-Info-3.png)\n</center>\n\n# 3.生成 BuildConfig.plist 文件\n然后我们编译一次就可以发现，这段代码会在编译时在工程所在目录下生成一个 BuildConfig.plist 文件，其中包含了本次构建的时间和当前版本的 GitHash，以后每一次 XCode 构建时都会自动更新该文件，详细内容如下：\n```bash\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n        <key>BUILD_TIME</key>\n        <string>2016-03-30T09:38:04+0800</string>\n        <key>GIT_SHA</key>\n        <string>3e4d213</string>\n</dict>\n</plist>\n```\n\n<center>\n![iOS-Build-Info-4](/images/iOS-Build-Info-4.png)\n</center>\n\n# 4.获取 BuildConfig.plist 文件内容\n将 BuildConfig.plist 添加到我们的工程中：\n\n<center>\n![iOS-Build-Info-5](/images/iOS-Build-Info-5.png)\n</center>\n\n然后在需要获取构建信息的位置添加如下代码就能成功获取构建时间和 Git Hash 值：\n```swift\n//输出构建信息\nvar bulidTime: String!\nvar gitSha: String!\nif let buildConfigFilePath = NSBundle.mainBundle()\n    .pathForResource(\"BuildConfig\", ofType: \"plist\") {\n    if let dict = NSDictionary(contentsOfFile: buildConfigFilePath) {\n        bulidTime = dict[\"BUILD_TIME\"] as? String ?? \"未知\"\n        gitSha = dict[\"GIT_SHA\"] as? String ?? \"未知\"\n    }\n}\nprint(\"BUILD_TIME: \\(bulidTime)\")\nprint(\"GIT_SHA: \\(gitSha)\")\n```\n结果如图所示：\n\n<center>\n![iOS-Build-Info-6](/images/iOS-Build-Info-6.png)\n</center>\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2016/03/08/iOS-Build-Info   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Nothing"],"categories":["iOS"]},{"title":"OS X 下使用 Jekyll 和 Coding Pages 搭建静态博客","url":"/2016/03/01/Jekyll-Coding-Pages/","content":"\nJekyll 是一个免费的简单静态网页生成工具，可以配合第三方服务例如 Disqus 实现一些扩展功能，不需要数据库支持。并且 Jekyll 可以部署在Github 或 Coding 上，可以绑定自己的域名，而且目前这是完全免费的。\n\n---\n# 1，Git 安装  \n搭建博客需要用到 git，git --version 命令可查看本机是否已安装 git，若未安装可参考[这篇博文](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000/)进行安装。\n\n# 2，Gem 安装/设置  \n安装 Jekyll 需要用到包管理器 gem，gem -v 命令可查看本机是否已安装 gem，若未安装请自行安装。 \n由于众所周知的原因，国内访问官方默认 gem sources 源速度不是十分理想，所以建议切换成国内的，利用 gem sources -l 命令可查看当前 gem sources 源：\n``` bash\ngem sources --remove http://rubygems.org/\n```\n然后利用以下命令将其替换为淘宝的（注意：这里的 http://rubygems.org/ 替换成当前 gem sources 源地址）： \n``` bash\ngem sources -a https://ruby.taobao.org/\n```\n\n# 3，安装 Jekyll 到本地  \n因为打算在 Coding Pages 上搭建，根据 [Coding 帮助文档](https://coding.net/help/doc/pages/index.html)，Coding Pages 目前支持 jekyll 2.4.0，所以我们需要指定版本安装 Jekyll，终端执行以下命令： \n``` bash\nsudo gem install jekyll -v '2.4.0'\n```\n输入密码后等待安装完成，执行以下命令尝试查看 Jekyll 版本号： \n``` bash\njekyll -v\n```\n若能正确显示版本号 jekyll 2.4.0 表示安装成功。 \n\n# 4，本地建立博客  \n从零开始手动编写的话可以参考：[这篇博文](http://www.blogways.net/blog/2013/04/13/jekyll-usage.html)，同时网上有大量开发者们分享的模板可供选择使用：  \n[Jekyll Themes](http://jekyllthemes.org/)  \n[Github Jekyll Sites](https://github.com/jekyll/jekyll/wiki/Sites)  \n本博客的搭建我选择了在该[模板](https://github.com/sl4m/skim.cc)的基础上进行修改，在这里对原作者表示感谢，🙏\n在终端中切换到合适的目录下执行以下命令：\n``` bash\ngit clone https://github.com/sl4m/skim.cc.git\n```\n将模板 git 仓库下载到本地。\n\n# 5，本地效果预览  \n终端中用 cd 命令切换到本地博客所在目录，即 skim.cc 目录下，执行 jekyll server 命令启动本地服务器，若启动成功可在浏览器中访问 http://0.0.0.0:4000/ 进行预览。 \n\n# 6，上传到 Coding Pages  \n在 Coding 新建一个项目，将博客所在项目 push 到新建的项目中，推荐的做法是创建一个新的 coding-pages 分支来作为启动 Coding Pages 之用（其他分支名也可以），然后切换到 Pages 标签，开启 pages 服务，分支名填写为我们需要的分支，这里是 coding-pages。\n\n# 7，服务器效果预览  \n这时 Coding 会提供一个类似 {user_name}.coding.me/{project_name} 的链接用于访问，例如本博客的是： \n``` bash\n[http://eyrefree.coding.me/blog.eyrefree.org](http://eyrefree.coding.me/blog.eyrefree.org)\n```\n\n# 8，绑定域名  \n默认提供的链接可能过长或者不便于日常使用，我们也可以绑定自己的域名。 \n首先，需要提前准备一个域名，然后打开自己的域名控制面板，新建一个 CNAME 解析到 {user_name}.coding.me，例如我的是将 blog.eyrefree.org 解析到 eyrefree.coding.me； \n然后，打开 Coding 项目页面切换到 pages 项，填入刚才的设置解析的域名 blog.eyrefree.org，点击“添加域名绑定”按钮即可，在浏览器中直接访问 blog.eyrefree.org 就能成功打开。\n有时可能由于缓存或者解析时间的问题，稍等片刻即可。 \n\n# 9，编写博文  \n接下来就是日常的博文编写啦，这里是使用 markdown 格式的，编写完成后添加到 _posts 目录下 push 到 Coding 服务器即可，具体可参考[这篇博文](https://segmentfault.com/a/1190000000406013)。\n\n---\n嘛，大概就是这些内容了，有遗漏的话后期会继续补充，😝，[我的博客](http://www.eyrefree.org)在原模版基础上将 Google 统计，Disqus 评论，feedburner 等替换为了自己的，其他的一些修改详情参见我的 Coding 仓库的 Jekyll 分支：\n[https://coding.net/u/eyrefree/p/blog.eyrefree.org/git](https://coding.net/u/eyrefree/p/blog.eyrefree.org/git)\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2016/03/01/Jekyll-Coding-Pages   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。\n","tags":["Jekyll"],"categories":["Blog"]},{"title":"iOS 集成广点通移动 App 激活数据统计 API 上报方案","url":"/2016/02/18/iOS-GuangDianTong/","content":"\niOS 集成广点通移动 App 激活数据统计 API 上报方案。\n\nDemo 地址：[https://github.com/EyreFree/EFGuangDianTongDemo](https://github.com/EyreFree/EFGuangDianTongDemo)\n\n---\n\n# 一，获取参数\n\n## 1，Apple ID\n\nApple ID 是一个数字，每一个 iOS 应用都有一个 Apple ID，打开 [iTunesConnect](http://itunesconnect.apple.com)，点击我们所需要集成广点通的 App 进入详情页面，点击左边的“App 信息”，找到其中的“综合信息”一项，其中包含我们需要的 Apple ID，如下图所示：\n\n<center>\n![iOS-GuangDianTong-1](/images/iOS-GuangDianTong-1.png)\n</center>\n\n## 2，UID\n\nUID 是一个数字，它是我们在广点通的账户 ID，打开[广点通](http://e.qq.com)进入管理平台，在最顶部的显示的账户信息中的“账户 ID”就是我们需要的 UID，如下图所示：\n\n<center>\n![iOS-GuangDianTong-2](/images/iOS-GuangDianTong-2.png)\n</center>\n\n## 3，EncryptKey 和 SignKey\n\n每一个 AppID 广点通会分配给我们一个加密密钥 encrypt_key 和一个签名密钥 sign_key，打开[广点通](http://e.qq.com)进入管理平台，点击左边的“工具箱”然后选择“转化跟踪”，然后点击“创建新转化”，依次输入信息创建对应 App 的转化，注意“转化方案”一项选择“API方案二”，提交后会在列表中出现一个我们新创建的转化，点击“查看”，就会得到我们需要的 encrypt_key 和 sign_key，如下图所示：\n\n<center>\n![iOS-GuangDianTong-3](/images/iOS-GuangDianTong-3.png)\n</center>\n\n# 二，实现 API 上报方案\n\n根据文档实现了 API 上报方案流程，代码参见：[https://github.com/EyreFree/EFGuangDianTongDemo/blob/master/EFGuangDianTongDemo/EFGuangDianTong.swift](https://github.com/EyreFree/EFGuangDianTongDemo/blob/master/EFGuangDianTongDemo/EFGuangDianTong.swift)\n\n# 三，调用方式\n\n## 1，添加第三方库\n\n需要添加 Alamofire 用于网络操作，Demo 中是通过 CocoaPods 的方式引用，所以在将 Demo Clone 下来后要先进行 pod install 操作，具体内容可参考这篇博文：[CocoaPods安装和使用教程](http://code4app.com/article/cocoapods-install-usage)\n\n## 2，添加头文件\n\n由于实现 API 上报方案的过程中需要用到 MD5 加密，所以需要添加相应的 Objective-C 头文件：\n\n```\n#import <CommonCrypto/CommonDigest.h>\n```\n\n由于我们这里是 Swift 工程，所以添加 OC 头文件需要通过给项目添加一个用于桥接的头文件，具体过程可参考：[IOS --- OC与Swift混编](http://blog.sina.com.cn/s/blog_8d1bc23f0102v5tl.html)\n\n## 3，添加实现代码\n\n将 Demo 中的 EFGuangDianTong.swift 文件添加到需要集成广点通统计的项目中。\n\n## 4，调用 API 上报方法\n\n在 AppDelegate 的 didFinishLaunchingWithOptions 方法中合适的地方添加如下代码：\n\n```swift\nEFGuangDianTong.sharedInstance.Schema2(\n      appid: 111111111,              //替换为我们的 Apple ID\n      uid: 222222,                   //替换为我们的 UID\n      signKey: \"xxxxxxxxxxxxxxxx\",   //替换为我们的 sign_key\n      encryptKey: \"zzzzzzzzzzzzzzzz\" //替换为我们的 encrypt_key\n)\n```\n\n## 5，查看返回状态\n\n若上报成功，则 XCode 下方的控制台会输出“广点通上报:成功”；\n若失败则会根据返回码输出具体失败原因，可以根据输出的错误信息来做相应的检查。\n\n# 四，备注\n\n集成广点通需要使用 IDFA，请在 App 提交审核时注意勾选相应选项，否则容易导致二进制文件被拒绝。\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2016/02/18/iOS-GuangDianTong   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Nothing"],"categories":["iOS"]},{"title":"Swift UIColor 添加从十六进制值初始化的扩展","url":"/2015/09/10/Swift-UIColor-Hex/","content":"\n在实际开发中，我们拿到的设计图上的颜色往往标注的是十六进制的，而在不添加第三方库的情况下 UIColor 并不支持从十六进制数字初始化，手动将十六进制颜色转化为 RGB 形式十分浪费精力，我们可以通过为 UIColor 添加扩展的方式来支持直接从十六进制数值初始化从而为我们的开发带来便利。\n\n---\n# 1.添加文件\n在项目中添加一个用于编写扩展代码的文件，将其命名为 `UIColor+valueRGB.swift`。\n\n# 2.添加扩展代码\n在第一步创建的文件中添加如下代码：\n```swift\nimport UIKit\n\nextension UIColor {\n    //用数值初始化颜色，便于生成设计图上标明的十六进制颜色\n    convenience init(valueRGB: UInt) {\n        self.init(\n            red: CGFloat((valueRGB & 0xFF0000) >> 16) / 255.0,\n            green: CGFloat((valueRGB & 0x00FF00) >> 8) / 255.0,\n            blue: CGFloat(valueRGB & 0x0000FF) / 255.0,\n            alpha: CGFloat(1.0)\n        )\n    }\n}\n```\n\n# 3.调用\n然后我们就可以在工程中以如下方式直接从十六进制数字初始化 UIColor 了：\n```swift\nlet testColor = UIColor(valueRGB: 0x666666)\n```\n\n---\n实际上这里没有做十六进制的限定，只需要是 UInt 类型都可以，但是貌似暂时没发现什么实际意义，用来生成随机颜色？或者是画颜色表？大家可以自行挖掘下，😊\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2015/09/10/Swift-UIColor-Hex   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Swift"],"categories":["iOS"]},{"title":"XCode 中 Swift / Objective-C / C / C++ 混合编程","url":"/2015/09/06/XCode-Swift-Objective-C-C-C++/","content":"\nSwift 是苹果于2014年 WWDC 发布的一种新的用于编写 iOS 和 OS X 应用的编程语言，可与 Objective-C / C / C++ 进行混合编程。\n\n---\n# 1.Objective-C 调用 C\nObjective-C 是 C 的超集，所以 Objective-C 完全兼容 C，可以直接在 Objective-C 代码中写 C 代码无需修改。\n\n# 2.Objective-C 调用 C++\nXcode 需要源文件以 .mm 为扩展名，这样才能启动编译器的 Objective-C++ 扩展，在 .mm 文件内可以编写 C++ 代码也可以编写 Objective-C 代码，支持大部分的 C++ 的特性，几乎完全兼容 GNU C/C++。\n\n# 3.Swift 调用 Objective-C\n## 1.添加桥接文件\n添加一个新的头文件到工程中作为桥接文件，建议命名为 `{project_name}-Bridging-Header.h`，这里我命名为 SwiftMixedDemo-Bridging-Header.h，如图所示：\n\n<center>\n![XCode-Swift-Objective-C-C-C++-1](/images/XCode-Swift-Objective-C-C-C++-1.png)\n</center>\n\n## 2.设置 Objective-C Bridging Header\n选中工程名，切换到 Build Settings 选项卡，选中 All，在右上角的搜索栏中输入 bridging 找到 `Objective-C Bridging Header` 一项，并将其设为 `{project_name}/{project_name}-Bridging-Header.h`，这里我设为 SwiftMixedDemo/SwiftMixedDemo-Bridging-Header.h，如图所示：\n\n<center>\n![XCode-Swift-Objective-C-C-C++-2](/images/XCode-Swift-Objective-C-C-C++-2.png)\n</center>\n\n## 3.添加 Objective-C 文件\n将需要引入的 Objective-C 文件添加到项目，然后将相应的头文件添加到桥接文件 SwiftMixedDemo-Bridging-Header.h 中：\n\n<center>\n![XCode-Swift-Objective-C-C-C++-3](/images/XCode-Swift-Objective-C-C-C++-3.png)\n</center>\n\n接下来即可正常调用 Objective-C 文件中的代码。\n\n## 4.Swift 调用 C/C++\n并且 Swift 不能直接调用 C/C++，但可以通过调用 Objective-C 代码的方式间接调用 C/C++。\n\n---\nPS：`{project_name}` 代指工程名。\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2015/09/06/XCode-Swift-Objective-C-C-C++   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Swift"],"categories":["iOS"]},{"title":"在需要兼容 iOS 7.0 及以下的项目中使用 Alamofire","url":"/2015/08/14/iOS7-Alamofire/","content":"\nAlamofire 是 iOS 和 OS X 上最受欢迎的第三方库之一，它在 [Github](https://github.com/Alamofire/Alamofire) 上面获得了 15638 个 stars 和2304 个 forks，是使用最广的开源项目之一。\n\n---\n# 1.官方描述\n```\nEmbedded frameworks require a minimum deployment target of iOS 8 or OS X Mavericks.\nTo use Alamofire with a project targeting iOS 7, you must include all Swift files located inside the Source directory directly in your project. See the ‘Source File’ section for additional instructions.\n```\n官方文档指出在需要兼容 iOS 7 的项目中一定要包含所有 Alamofire 源文件。\n\n# 2.添加方法\n## 1.添加 Alamofire 子模块\n首先添加 submodule，将 Alamofire 作为当前项目的一个子模块：\n```bash\n#添加子模块：\ngit submodule add https://github.com/Alamofire/Alamofire.git Alamofire\n#初始化子模块：\ngit submodule init\n#更新子模块：\ngit submodule update\n```\n\n## 2.添加源文件到工程\n将 Alamofire 目录下的 Source 目录中的所有 `.swift` 文件以引用方式添加到项目中去，如图所示：\n\n<center>\n![iOS7-Alamofire-1](/images/iOS7-Alamofire-1.png)\n</center>\n\n# 3.调用方法\n直接调用方法即可，不需要通过 `Alamofire.` 前缀，如图所示：\n\n<center>\n![iOS7-Alamofire-2](/images/iOS7-Alamofire-2.png)\n</center>\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2015/08/14/iOS7-Alamofire   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Alamofire"],"categories":["iOS"]},{"title":"iOS 设置 Launch Image 启动图片","url":"/2015/06/01/iOS-LaunchImage/","content":"\n# 1、添加图片资源\n打开工程，进入 `Images.xcassets`，出现图片资源列表，对列表空白处右击单击，在弹出菜单中选择 `New Launch Image`，出现 `LaunchImage` 的空文件夹，按要求添加若干尺寸的 Launch 图片：\n\n<center>\n![iOS-LaunchImage-1](/images/iOS-LaunchImage-1.jpg)\n</center>\n \n# 2、修改工程设置\n选中工程名，然后在 Targets 中再次选中，接着选择 General，找到 `App Icons and Launch Images`，将第二项 `Launch Image Source` 设为第一步中创建的 LaunchImage，将第三项 `Launch Screen File` 设为空即可。\n\n<center>\n![iOS-LaunchImage-2](/images/iOS-LaunchImage-2.jpg)\n</center>\n\n接下来 Run 一下工程，启动 App 时就可以出现我们上面设置的启动图片啦，😊\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2015/06/01/iOS-LaunchImage   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Nothing"],"categories":["iOS"]},{"title":"WordPress 使用笔记","url":"/2015/05/31/WordPress-Notes/","content":"\n最近在看一些有意思的东西，想要写一些笔记作为记录，时间久了不记得了还可以回头来看看。然后其实本来是用 CSDN 博客的，但是不知道为啥米（正文加了链接？），最近每次修改或者发布都需要审核（不嗨森），然后就想自己搭一个玩一下，嗯，酱紫！\n \n买了国内某服务器发现需要备案（然后百度了一下发现别人都是备好了案才买服务器的，年少无知，囧），然后备好了案发现域名服务提供商还不提供域名隐私保护（不支持.org的为虾米，不嗨森），好了不管了，反正填的资料真真假假的，233333，开始玩弄 WP 吧。\n \n# 1、选择主题\n\n首先，挑一个好看（或者自认为好看）的主题（什么，你问主题在哪里？外观->主题->添加 哟，是不是一下子粗来好多~，嘛，要是没出来好多，或者出来好多边框和标题但是没有看到缩略图的话，您可能需要一个梯子，别问我什么是梯子，我不懂，0_o）。\n \n# 2、设置用户头像\n\n主题换好以后，发现用户头像那里是空的耶（或者是个占位图？总之好蓝看）。默认情况下用户头像是木有的（可能是由于模板的原因？反正我的没有，有的话请跳过本步骤），这时候我们可以使用一个叫 Simple Local Avatar 的插件来实现添加用户头像的功能（插件->安装插件->搜索），安装完插件并且开启后就会在 用户->个人资料 中出现 Avatar 的选项，选择自己喜欢的头像图片上传即可。\n \n# 3、添加友链\n\n嗯，接下来就是把几个中二病的博客链接加到友情链接里面去啦，默认情况下友情链接也是木有的（同上，有的话请跳过本步骤），这时候我们可以使用一个叫 Link Manager 的插件来实现添加友情链接的功能，插件安装完成并且开启后在控制面板（或者叫后台？）的菜单项中会出现 链接 一栏，然后点进去就可以给博客加友链了，是不是很简单！\n \n# 4、去除 Google 相关引用\n\n嗯，针对一般的主题设置上面这些应该已经差不多了，但是，由于 WP 的主题大部分作者是国外的，所以中间可能有些主题使用了谷歌字体或者谷歌地图之类的谷歌 API （很不幸，我使用的这个主题就使用了大量的这类东东，蓝后打开的时候死慢死慢的），简单地看了一下他人的解决办法，有使用 Disable Google Fonts 和 Disable Google Maps 这类插件来解提速的，大家可以试试，反正我用了还是慢得要shi（可能是还有其他 Google 的东东在里面？），然后用了比较原始但有效的方法：将网站整站打包下载然后用 Sublime Text 搜索所有包含 googleapis 的行，然后注释掉它们就可以了（嘛，貌似工作量略大，而且修改的时候要记住编码方式要和原来的文件一样，同时请童鞋们注意：主题升级以后会恢复原样，所以升级主题时请慎重！）\n\n<center>\n![WordPress-Notes-1](/images/WordPress-Notes-1.jpg)\n</center>\n \n# 5、博客提速\n\n第4步完成以后，博客的访问速度已经得到了很大程度的提升，如果在此基础上安装一个名为 WP Super Cache 可能（“可能”是什么么鬼…）会使速度进一步提升（关于这个插件的详细信息可以参考[WP Super Cache使用全攻略](http://plugins.wopus.org/best-plugin/242.html)）。\n \n# 6、添加邮件通知\n\n然后 WP 默认是没有开启邮件发送功能的， WP SMTP 这款插件可以帮助我们实现“邮件通知”、“用户注册邮件发送”等一些列与电子邮件服务相关的功能，只需要简单设置邮件服务器等参数即可（关于这个插件的详细信息可以参考[WordPress SMTP发送邮件插件：WP SMTP](http://www.wpdaxue.com/wordpress-smtp-email.html)）。\n \n# 7、反恶意注册\n\n开启了注册功能以后，遇到大量恶意注册，大量用户名是随机字符串的雅虎邮箱申请注册，尝试在注册页面加了验证码，具体方法可以参考[WordPress自定义用户注册页面插件](http://www.ludou.org/wordpress-ludou-custom-user-register.html)、[WordPress评论、注册、登录验证码](http://www.zhiyanblog.com/wordpress-si-captcha-anti-spam-plugin.html)、[wordpress受到恶意注册，注册登录页面增加验证码](http://www.diandidao.com/573.html)，这几款插件都能有效阻止此类恶意行为。\n\n<center>\n![WordPress-Notes-2](/images/WordPress-Notes-2.jpg)\n</center>\n \n未完待续，QAQ\n\n---\n\n2016 年 3 月 28 日续：\n最近用 Hexo 搭建了自己的纯静态博客来代替 WordPress，然后在把原来的博客迁移过来，😌。\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2015/05/31/WordPress-Notes   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["WordPress"],"categories":["Blog"]},{"title":"Git 常用命令","url":"/2015/04/09/Git-Commands/","content":"\nGit 常用命令备忘\n\n---\n\n## SubModule\n\n### 1. 获取所有 SubModule\n\n```bash\ngit submodule update --init --recursive\n```\n\n### 2. 删除某个 SubModule\n\n例如：submodule_xxx\n\n```bash\ngit submodule deinit submodule_xxx\ngit rm submodule_xxx\nrm -rf .git/modules/submodule_xxx\n```\n\n## Tag\n\n### 1. 添加 Tag 并上传本地 Tag 到服务器\n\n例如：2.333\n\n```bash\ngit tag -a 2.333 -m \"2.333 版本的备注信息.\"\ngit push origin --tags\n```\n\n### 2. 删除本地 Tag 并同步到远程\n\n例如：2.333\n\n```bash\ngit tag -d 2.333\ngit push origin :refs/tags/2.333\n```\n\n## Branch\n\n### 1. 查看所有分支\n\n```bash\ngit branch\n```\n\n### 2. 同步本地与远程分支\n\n删除远程不存在的本地分支\n\n```bash\ngit fetch -p\n```\n\n## Commit\n\n### 1. 合并本地的最后两次 Commit\n\n```bash\ngit reset --soft HEAD^git commit --amend\n```\n\n### 2. 修改上一次的 Commit 信息\n\n```bash\ngit commit --amend\n```\n\n### 3. 撤销所有未提交的本地修改\n\n```bash\ngit add -A\ngit checkout .\ngit cehckout -f\n```\n\n## Remote\n\n### 1. 删除远程仓库地址\n\n```bash\ngit remote remove origin\n```\n\n### 2. 添加远程仓库地址\n\n```bash\ngit remote add origin https://git.coding.net/eyrefree/xxx.git\n```\n\n### 3. Push 本地分支到指定远程分支\n\n例如：Push 本地当前分支到远程仓库 origin 的 master 分支\n\n```bash\ngit push -u origin master\n```\n\n## Other\n\n### 1. 设置本地用户名、邮箱\n\n例如：设置用户名为 eyrefree，邮箱为 eyrefree@eyrefree.org\n\n```bash\ngit config --global user.name \"eyrefree\" git config --global user.email eyrefree@eyrefree.org\n```\n\n## PS\n\n最后，转载一张觉得挺棒的图片：\n\n![](/images/git.png)\n\n---\n\n更多 Git 常用命令可参考：[常用 Git 命令清单](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\n或查阅官方文档：[Pro Git book](https://git-scm.com/book/zh/v2)\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2015/04/09/Git-Commands   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Nothing"],"categories":["Git"]},{"title":"Windows 7 下 QT 5.1.1 for Android 开发环境的搭建与配置","url":"/2013/11/08/Windows7-QT-Android/","content":"\nQt 是诺基亚开发的一个跨平台的 C++ 图形用户界面应用程序框架，对于一些想要开发 Android 的应用但是又不想学习 Java 的开发人员而言，Qt 是一个很好选择。\n\n本次使用的操作系统为 Windows 7 64 位，用的是 32 位的安装包，32 位系统没有验证过。  \n\n---\n\n# 一、下载安装包\n\n首先下载以下安装包，如果提供的链接失效请自行下载：\n\n（1）Android SDK （Windows 32-bit ADT版）：\n\n【直接下载】[http://dl.google.com/android/adt/adt-bundle-windows-x86-20131030.zip](http://dl.google.com/android/adt/adt-bundle-windows-x86-20131030.zip)\n\n（2）Android NDK（Windows 32-bit）：\n\n【直接下载】[http://dl.google.com/android/ndk/android-ndk-r9b-windows-x86.zip](http://dl.google.com/android/ndk/android-ndk-r9b-windows-x86.zip)\n\n（3）Java JDK（Windows 32-bit）：\n\n【手动下载】[http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html)\n\n（4）Apache-Ant：\n\n【直接下载】[http://mirrors.cnnic.cn/apache//ant/binaries/apache-ant-1.9.2-bin.zip](http://mirrors.cnnic.cn/apache//ant/binaries/apache-ant-1.9.2-bin.zip)\n\n（5）QT 5.1.1 for Android （Windows 32-bit  离线版）：\n\n【直接下载】[http://mirrors.hustunique.com/qt/official_releases/qt/5.1/5.1.1/qt-windows-opensource-5.1.1-android-x86-win32-offline.exe](http://mirrors.hustunique.com/qt/official_releases/qt/5.1/5.1.1/qt-windows-opensource-5.1.1-android-x86-win32-offline.exe)  \n\n# 二、安装包的解压与安装\n\n接下来解压、安装下载好的各安装包：\n\n（1）Android SDK：【解压】解压到  D:\\ADT 目录下  \n（2）Android NDK：【解压】解压到 D:\\NDK 目录下  \n（3）Java JDK（Windows 35-bit）：【安装】安装过程中有两次要选择安装路径，注意请根据自己安装的版本自行修改，后面设置环境变量需要用到，这里我第一次填写：\n\n```\nD:\\Java\\jdk1.7.0_45  \n```\n\n第二次填写：\n\n```\nD:\\Java\\jre7  \n```\n\n（4）Apache-Ant：【解压】解压到 D:\\ANT 目录下  \n（5）QT 5.1.1 for Android（Windows 35-bit 离线版）：【安装】安装到 D:\\QT 目录下  \n\n# 三、设置环境变量\n\n根据第二步中的相关路径，设置系统环境变量：  \n\n## 1，添加新的环境变量\n\n右键单击 我的电脑 -> 属性 -> 高级系统设置 -> 环境变量，在系统变量中新建以下变量：\n\n（1）变量名：JAVA_HOME，变量值：\n\n```\nD:\\Java\\jdk1.7.0_45  \n```\n\n（2）变量名：CLASSPATH，变量值：\n\n```\n.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar;  \n```\n\n【注意最前面的点号 . 和最后面的分号 ; 不能漏掉】  \n（3）变量名：ANDROID_SDK_HOME，变量值：\n\n```\nD:\\ADT\\sdk\\  \n```\n\n（4）变量名：ANT_HOME，变量值：\n\n```\nD:\\ANT  \n```\n\n## 2，修改系统变量\n\n在系统变量里找到变量 Path ，选择”编辑“，在最后面添加：\n\n```\n%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;%ANDROID_SDK_HOME%;  \n```\n\n【注意最后面的分号 ; 不能漏掉】  \n\n<center>\n![Windows7-QT-Android-1](/images/Windows7-QT-Android-1.jpeg)\n</center>\n\n# 四、Qt Creator 设置\n\n打开Qt Creator，单击 工具 -> 选项，出现选项界面后选择 Android，分别做如下设置：\n\n（1）Android-SDK的路径：\n\n```\nD:\\ADT\\sdk  \n```\n\n（2）Android NDK的路径：\n\n```\nD:\\NDK  \n```\n\n（3）ANT的路径： \n\n```\nD:\\ANT\\bin\\ant.bat  \n```\n\n（4）JDK location：\n\n```\nD:\\Java\\jdk1.7.0_45  \n```\n\n<center>\n![Windows7-QT-Android-2](/images/Windows7-QT-Android-2.jpeg)\n</center>\n\n# 五、添加虚拟机\n\n单击 启动Android AVD管理器，出现Android Virtual Device Manager界面，单击 New 创建一个Android虚拟设备。\n\n<center>\n![Windows7-QT-Android-3](/images/Windows7-QT-Android-3.jpeg)\n</center>\n\n# 六、建立测试工程\n\n经过以上这些步骤，开发环境基本配置完成，接下来我们建立一个简单的工程来验证配置是否正确：\n\n（1）重新打开Qt Creator，选择 文件 -> 新建文件或项目，出现项目创建向导，选择 QT Gui 应用：  \n\n<center>\n![Windows7-QT-Android-4](/images/Windows7-QT-Android-4.jpeg)\n</center>\n\n（2）然后下一步，工程路径任选。  \n【但是切记，绝对不要在路径内包含任何空格，这里我使用的是D:\\QT-WorkSpace，否则会出现各种意想不到的编译错误！】  \n（3）然后下一步，选择 Android for arm：  \n\n<center>\n![Windows7-QT-Android-5](/images/Windows7-QT-Android-5.jpeg)\n</center>\n\n（4）后面的信息暂时不需要过多关注，直接下一步即可，直至完成项目创建。  \n\n<center>\n![Windows7-QT-Android-6](/images/Windows7-QT-Android-6.jpeg)\n</center>\n\n（5）项目创建完毕后，右键 项目，选择 构建，若成功则继续下一步，否则请对照上文寻找可能的出错步骤进行相应修改或返回本文开头尝试重新开始配置过程。  \n\n<center>\n![Windows7-QT-Android-7](/images/Windows7-QT-Android-7.jpeg)\n</center>\n\n（6）项目构建成功后，右键  \n项目，选择 运行，Android虚拟设备将会自动打开，启动过程过程较慢，耐心等候。  \n（7）若无意外，将会成功运行该空项目生成的apk，因为这里是个空的项目，什么也没写，所以当然什么也没有，效果如图，表明环境配置成功。  \n\n<center>\n![Windows7-QT-Android-8](/images/Windows7-QT-Android-8.jpeg)\n</center>\n\n---\n\n到这里就应该已经完成了，接下来可以使用 C++ 动手开始 QT for Android 开发了，😝。\n\n---\n\n> 如有任何知识产权、版权问题或理论错误，还请指正。   \n> https://www.eyrefree.org/2013/11/08/Windows7-QT-Android   \n> 如文中无特殊说明，本站均使用以下协议保护：[署名-非商业性使用-禁止演绎](http://creativecommons.org/licenses/by-nc-nd/3.0/cn/)。   \n","tags":["Qt"],"categories":["Environment"]}]